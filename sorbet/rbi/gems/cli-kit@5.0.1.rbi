# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-kit` gem.
# Please instead update this file by running `bin/tapioca gem cli-kit`.


# source://cli-kit//lib/cli/kit.rb#11
module CLI; end

# source://cli-kit//lib/cli/kit.rb#12
module CLI::Kit
  class << self
    # Mirrors the API of Kernel#raise, but with the addition of a few new
    # optional keyword arguments. `bug` and `silent` attach metadata to the
    # exception being raised, which is interpreted later in the ErrorHandler to
    # decide what to print and whether to submit to bugsnag.
    #
    # `depth` is used to trim leading elements of the backtrace. If you wrap
    # this method in your own wrapper, you'll want to pass `depth: 2`, for
    # example.
    #
    # source://cli-kit//lib/cli/kit.rb#135
    sig do
      params(
        exception: T.any(::Class, ::Exception, ::String),
        string: T.untyped,
        array: T.nilable(T::Array[::String]),
        cause: T.nilable(::Exception),
        bug: T.nilable(T::Boolean),
        silent: T.nilable(T::Boolean),
        depth: ::Integer
      ).returns(T.noreturn)
    end
    def raise(exception = T.unsafe(nil), string = T.unsafe(nil), array = T.unsafe(nil), cause: T.unsafe(nil), bug: T.unsafe(nil), silent: T.unsafe(nil), depth: T.unsafe(nil)); end
  end
end

# bug:false; silent: false
#
# source://cli-kit//lib/cli/kit.rb#78
class CLI::Kit::Abort < ::CLI::Kit::GenericAbort
  # source://cli-kit//lib/cli/kit.rb#82
  sig { returns(T::Boolean) }
  def bug?; end
end

# bug:false; silent:true
#
# source://cli-kit//lib/cli/kit.rb#99
class CLI::Kit::AbortSilent < ::CLI::Kit::GenericAbort
  # source://cli-kit//lib/cli/kit.rb#103
  sig { returns(T::Boolean) }
  def bug?; end

  # source://cli-kit//lib/cli/kit.rb#108
  sig { returns(T::Boolean) }
  def silent?; end
end

# source://cli-kit//lib/cli/kit/args.rb#7
module CLI::Kit::Args; end

# source://cli-kit//lib/cli/kit/args/definition.rb#8
class CLI::Kit::Args::Definition
  # source://cli-kit//lib/cli/kit/args/definition.rb#81
  sig { void }
  def initialize; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#27
  sig { params(name: ::Symbol, short: T.nilable(::String), long: T.nilable(::String), desc: T.nilable(::String)).void }
  def add_flag(name, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#46
  sig do
    params(
      name: ::Symbol,
      short: T.nilable(::String),
      long: T.nilable(::String),
      desc: T.nilable(::String),
      default: T.nilable(T.any(::String, T.proc.returns(::String), T.proc.returns(T::Array[::String]), T::Array[::String])),
      required: T::Boolean,
      multi: T::Boolean
    ).void
  end
  def add_option(name, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil), required: T.unsafe(nil), multi: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#70
  sig do
    params(
      name: ::Symbol,
      required: T::Boolean,
      multi: T::Boolean,
      desc: T.nilable(::String),
      default: T.nilable(T.any(::String, T.proc.returns(::String))),
      skip: T.nilable(T.any(T.proc.returns(T::Boolean), T.proc.params(arg0: ::String).returns(T::Boolean)))
    ).void
  end
  def add_position(name, required:, multi:, desc: T.unsafe(nil), default: T.unsafe(nil), skip: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#18
  sig { returns(T::Array[::CLI::Kit::Args::Definition::Flag]) }
  def flags; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#234
  sig { params(name: ::Symbol).returns(T.nilable(::CLI::Kit::Args::Definition::Flag)) }
  def lookup_flag(name); end

  # @raise [InvalidLookup]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#257
  sig do
    params(
      name: ::String
    ).returns(T.nilable(T.any(::CLI::Kit::Args::Definition::Flag, ::CLI::Kit::Args::Definition::Option)))
  end
  def lookup_long(name); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#242
  sig { params(name: ::Symbol).returns(T.nilable(::CLI::Kit::Args::Definition::Option)) }
  def lookup_option(name); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#264
  sig { params(name: ::Symbol).returns(T.nilable(::CLI::Kit::Args::Definition::Position)) }
  def lookup_position(name); end

  # @raise [InvalidLookup]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#250
  sig do
    params(
      name: ::String
    ).returns(T.nilable(T.any(::CLI::Kit::Args::Definition::Flag, ::CLI::Kit::Args::Definition::Option)))
  end
  def lookup_short(name); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#21
  sig { returns(T::Array[::CLI::Kit::Args::Definition::Option]) }
  def options; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#24
  sig { returns(T::Array[::CLI::Kit::Args::Definition::Position]) }
  def positions; end

  private

  # source://cli-kit//lib/cli/kit/args/definition.rb#334
  sig { params(arg: T.any(::CLI::Kit::Args::Definition::Flag, ::CLI::Kit::Args::Definition::Position)).void }
  def add_name_resolution(arg); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#315
  sig { params(flagopt: ::CLI::Kit::Args::Definition::Flag).void }
  def add_resolution(flagopt); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#291
  sig { params(long: ::String).returns(::String) }
  def strip_long_prefix(long); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#303
  sig do
    params(
      short: T.nilable(::String),
      long: T.nilable(::String)
    ).returns([T.nilable(::String), T.nilable(::String)])
  end
  def strip_prefixes_and_validate(short, long); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#279
  sig { params(short: ::String).returns(::String) }
  def strip_short_prefix(short); end

  # @raise [InvalidPosition]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#274
  sig { params(position: ::CLI::Kit::Args::Definition::Position).void }
  def validate_order(position); end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#12
class CLI::Kit::Args::Definition::ConflictingFlag < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#11
class CLI::Kit::Args::Definition::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#133
class CLI::Kit::Args::Definition::Flag
  include ::CLI::Kit::Args::Definition::OptBase

  # source://cli-kit//lib/cli/kit/args/definition.rb#149
  sig { params(name: ::Symbol, short: T.nilable(::String), long: T.nilable(::String), desc: T.nilable(::String)).void }
  def initialize(name:, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#144
  sig { returns(::String) }
  def as_written_by_user; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#141
  sig { returns(T.nilable(::String)) }
  def long; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#138
  sig { returns(T.nilable(::String)) }
  def short; end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#13
class CLI::Kit::Args::Definition::InvalidFlag < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#14
class CLI::Kit::Args::Definition::InvalidLookup < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#15
class CLI::Kit::Args::Definition::InvalidPosition < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#90
module CLI::Kit::Args::Definition::OptBase
  # source://cli-kit//lib/cli/kit/args/definition.rb#97
  sig { returns(T.nilable(::String)) }
  def desc; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#94
  sig { returns(::Symbol) }
  def name; end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#100
module CLI::Kit::Args::Definition::OptValue
  # source://cli-kit//lib/cli/kit/args/definition.rb#104
  sig { returns(T.nilable(T.any(::String, T::Array[::String]))) }
  def default; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#113
  sig { returns(T::Boolean) }
  def dynamic_default?; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#123
  sig { returns(T::Boolean) }
  def multi?; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#128
  sig { returns(T::Boolean) }
  def optional?; end

  # source://cli-kit//lib/cli/kit/args/definition.rb#118
  sig { returns(T::Boolean) }
  def required?; end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#205
class CLI::Kit::Args::Definition::Option < ::CLI::Kit::Args::Definition::Flag
  include ::CLI::Kit::Args::Definition::OptValue

  # source://cli-kit//lib/cli/kit/args/definition.rb#221
  sig do
    params(
      name: ::Symbol,
      short: T.nilable(::String),
      long: T.nilable(::String),
      desc: T.nilable(::String),
      default: T.nilable(T.any(::String, T.proc.returns(::String), T.proc.returns(T::Array[::String]), T::Array[::String])),
      required: T::Boolean,
      multi: T::Boolean
    ).void
  end
  def initialize(name:, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil), required: T.unsafe(nil), multi: T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#161
class CLI::Kit::Args::Definition::Position
  include ::CLI::Kit::Args::Definition::OptBase
  include ::CLI::Kit::Args::Definition::OptValue

  # source://cli-kit//lib/cli/kit/args/definition.rb#180
  sig do
    params(
      name: ::Symbol,
      desc: T.nilable(::String),
      required: T::Boolean,
      multi: T::Boolean,
      default: T.nilable(T.any(::String, T.proc.returns(::String))),
      skip: T.nilable(T.any(T.proc.returns(T::Boolean), T.proc.params(arg0: ::String).returns(T::Boolean)))
    ).void
  end
  def initialize(name:, desc:, required:, multi:, default: T.unsafe(nil), skip: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/args/definition.rb#194
  sig { params(arg: ::String).returns(T::Boolean) }
  def skip?(arg); end
end

# source://cli-kit//lib/cli/kit/args.rb#8
class CLI::Kit::Args::Error < ::StandardError; end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#8
class CLI::Kit::Args::Evaluation
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#142
  sig { params(defn: ::CLI::Kit::Args::Definition, parse: T::Array[::CLI::Kit::Args::Parser::Node]).void }
  def initialize(defn, parse); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#149
  sig { void }
  def check_required_options!; end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#125
  sig { returns(::CLI::Kit::Args::Definition) }
  def defn; end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#110
  sig { returns(::CLI::Kit::Args::Evaluation::FlagProxy) }
  def flag; end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#182
  sig { params(flag: ::CLI::Kit::Args::Definition::Flag).returns(T::Boolean) }
  def lookup_flag(flag); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#201
  sig { params(opt: ::CLI::Kit::Args::Definition::Option).returns(T.nilable(T.any(::String, T::Array[::String]))) }
  def lookup_option(opt); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#215
  sig do
    params(
      position: ::CLI::Kit::Args::Definition::Position
    ).returns(T.nilable(T.any(::String, T::Array[::String])))
  end
  def lookup_position(position); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#115
  sig { returns(::CLI::Kit::Args::Evaluation::OptionProxy) }
  def opt; end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#128
  sig { returns(T::Array[::CLI::Kit::Args::Parser::Node]) }
  def parse; end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#120
  sig { returns(::CLI::Kit::Args::Evaluation::PositionProxy) }
  def position; end

  # @raise [TooManyPositions]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#163
  sig { void }
  def resolve_positions!; end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#131
  sig { returns(T::Array[::String]) }
  def unparsed; end

  private

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#222
  sig { returns(T::Array[::String]) }
  def args; end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#11
class CLI::Kit::Args::Evaluation::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#37
class CLI::Kit::Args::Evaluation::FlagProxy
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#56
  sig { params(evaluation: ::CLI::Kit::Args::Evaluation).void }
  def initialize(evaluation); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#41
  sig { params(sym: ::Symbol).returns(T::Boolean) }
  def method_missing(sym); end

  private

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#51
  sig { params(sym: ::Symbol, include_private: T::Boolean).returns(T::Boolean) }
  def respond_to_missing?(sym, include_private = T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#13
class CLI::Kit::Args::Evaluation::MissingRequiredOption < ::CLI::Kit::Args::Evaluation::Error
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#16
  sig { params(name: ::String).void }
  def initialize(name); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#21
class CLI::Kit::Args::Evaluation::MissingRequiredPosition < ::CLI::Kit::Args::Evaluation::Error
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#24
  sig { void }
  def initialize; end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#61
class CLI::Kit::Args::Evaluation::OptionProxy
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#80
  sig { params(evaluation: ::CLI::Kit::Args::Evaluation).void }
  def initialize(evaluation); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#65
  sig { params(sym: ::Symbol).returns(T.nilable(T.any(::String, T::Array[::String]))) }
  def method_missing(sym); end

  private

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#75
  sig { params(sym: ::Symbol, include_private: T::Boolean).returns(T::Boolean) }
  def respond_to_missing?(sym, include_private = T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#85
class CLI::Kit::Args::Evaluation::PositionProxy
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#104
  sig { params(evaluation: ::CLI::Kit::Args::Evaluation).void }
  def initialize(evaluation); end

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#89
  sig { params(sym: ::Symbol).returns(T.nilable(T.any(::String, T::Array[::String]))) }
  def method_missing(sym); end

  private

  # source://cli-kit//lib/cli/kit/args/evaluation.rb#99
  sig { params(sym: ::Symbol, include_private: T::Boolean).returns(T::Boolean) }
  def respond_to_missing?(sym, include_private = T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#29
class CLI::Kit::Args::Evaluation::TooManyPositions < ::CLI::Kit::Args::Evaluation::Error
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#32
  sig { void }
  def initialize; end
end

# source://cli-kit//lib/cli/kit/args/parser.rb#8
class CLI::Kit::Args::Parser
  # source://cli-kit//lib/cli/kit/args/parser.rb#64
  sig { params(definition: ::CLI::Kit::Args::Definition).void }
  def initialize(definition); end

  # source://cli-kit//lib/cli/kit/args/parser.rb#32
  sig do
    params(
      tokens: T::Array[::CLI::Kit::Args::Tokenizer::Token]
    ).returns(T::Array[::CLI::Kit::Args::Parser::Node])
  end
  def parse(tokens); end

  private

  # source://cli-kit//lib/cli/kit/args/parser.rb#108
  sig do
    params(
      arg: ::CLI::Kit::Args::Tokenizer::Token::OptionName,
      next_arg: T.nilable(::CLI::Kit::Args::Tokenizer::Token)
    ).returns(::CLI::Kit::Args::Parser::Node)
  end
  def parse_option(arg, next_arg); end

  # source://cli-kit//lib/cli/kit/args/parser.rb#74
  sig do
    params(
      token: ::CLI::Kit::Args::Tokenizer::Token,
      next_token: T.nilable(::CLI::Kit::Args::Tokenizer::Token)
    ).returns([::Symbol, ::CLI::Kit::Args::Parser::Node])
  end
  def parse_token(token, next_token); end
end

# source://cli-kit//lib/cli/kit/args/parser.rb#13
class CLI::Kit::Args::Parser::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/parser.rb#15
class CLI::Kit::Args::Parser::InvalidOptionError < ::CLI::Kit::Args::Parser::Error
  # source://cli-kit//lib/cli/kit/args/parser.rb#18
  sig { params(option: ::String).void }
  def initialize(option); end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#9
class CLI::Kit::Args::Parser::Node
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#13
  sig { void }
  def initialize; end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#17
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#87
class CLI::Kit::Args::Parser::Node::Argument < ::CLI::Kit::Args::Parser::Node
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#92
  sig { params(value: ::String).void }
  def initialize(value); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#103
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#98
  sig { returns(::String) }
  def inspect; end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#89
  sig { returns(::String) }
  def value; end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#57
class CLI::Kit::Args::Parser::Node::Flag < ::CLI::Kit::Args::Parser::Node
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#62
  sig { params(value: ::String).void }
  def initialize(value); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#74
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#69
  sig { returns(::String) }
  def inspect; end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#59
  sig { returns(::String) }
  def value; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#79
class CLI::Kit::Args::Parser::Node::LongFlag < ::CLI::Kit::Args::Parser::Node::Flag
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#49
class CLI::Kit::Args::Parser::Node::LongOption < ::CLI::Kit::Args::Parser::Node::Option
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#21
class CLI::Kit::Args::Parser::Node::Option < ::CLI::Kit::Args::Parser::Node
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#31
  sig { params(name: ::String, value: ::String).void }
  def initialize(name, value); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#44
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#39
  sig { returns(::String) }
  def inspect; end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#25
  sig { returns(::String) }
  def name; end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#28
  sig { returns(::String) }
  def value; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#83
class CLI::Kit::Args::Parser::Node::ShortFlag < ::CLI::Kit::Args::Parser::Node::Flag
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#53
class CLI::Kit::Args::Parser::Node::ShortOption < ::CLI::Kit::Args::Parser::Node::Option
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#108
class CLI::Kit::Args::Parser::Node::Unparsed < ::CLI::Kit::Args::Parser::Node
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#113
  sig { params(value: T::Array[::String]).void }
  def initialize(value); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#124
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#119
  sig { returns(::String) }
  def inspect; end

  # source://cli-kit//lib/cli/kit/args/parser/node.rb#110
  sig { returns(T::Array[::String]) }
  def value; end
end

# source://cli-kit//lib/cli/kit/args/parser.rb#23
class CLI::Kit::Args::Parser::OptionRequiresAnArgumentError < ::CLI::Kit::Args::Parser::Error
  # source://cli-kit//lib/cli/kit/args/parser.rb#26
  sig { params(option: ::String).void }
  def initialize(option); end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#8
module CLI::Kit::Args::Tokenizer
  class << self
    # source://cli-kit//lib/cli/kit/args/tokenizer.rb#64
    sig { params(raw_args: T::Array[::String]).returns(T::Array[::CLI::Kit::Args::Tokenizer::Token]) }
    def tokenize(raw_args); end

    # source://cli-kit//lib/cli/kit/args/tokenizer.rb#99
    sig { params(arg: ::String).returns(T::Array[::CLI::Kit::Args::Tokenizer::Token]) }
    def tokenize_short_option(arg); end
  end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#11
class CLI::Kit::Args::Tokenizer::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#21
class CLI::Kit::Args::Tokenizer::InvalidCharInShortOption < ::CLI::Kit::Args::Tokenizer::Error
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#24
  sig { params(short_option: ::String, char: ::String).void }
  def initialize(short_option, char); end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#13
class CLI::Kit::Args::Tokenizer::InvalidShortOption < ::CLI::Kit::Args::Tokenizer::Error
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#16
  sig { params(short_option: ::String).void }
  def initialize(short_option); end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#29
class CLI::Kit::Args::Tokenizer::Token
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#36
  sig { params(value: ::String).void }
  def initialize(value); end

  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#46
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#41
  sig { returns(::String) }
  def inspect; end

  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#33
  sig { returns(::String) }
  def value; end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#51
class CLI::Kit::Args::Tokenizer::Token::LongOptionName < ::CLI::Kit::Args::Tokenizer::Token::OptionName; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#50
class CLI::Kit::Args::Tokenizer::Token::OptionName < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#54
class CLI::Kit::Args::Tokenizer::Token::OptionValue < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#56
class CLI::Kit::Args::Tokenizer::Token::OptionValueOrPositionalArgument < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#55
class CLI::Kit::Args::Tokenizer::Token::PositionalArgument < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#52
class CLI::Kit::Args::Tokenizer::Token::ShortOptionName < ::CLI::Kit::Args::Tokenizer::Token::OptionName; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#57
class CLI::Kit::Args::Tokenizer::Token::UnparsedArgument < ::CLI::Kit::Args::Tokenizer::Token; end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://cli-kit//lib/cli/kit/base_command.rb#7
class CLI::Kit::BaseCommand
  include ::CLI::Kit::CommandHelp
  extend ::CLI::Kit::CommandHelp::ClassMethods

  abstract!

  # source://cli-kit//lib/cli/kit/base_command.rb#29
  sig { returns(T::Boolean) }
  def has_subcommands?; end

  class << self
    # source://cli-kit//lib/cli/kit/base_command.rb#23
    sig { params(args: T::Array[::String], command_name: ::String).void }
    def call(args, command_name); end

    # source://cli-kit//lib/cli/kit/base_command.rb#18
    sig { returns(T::Boolean) }
    def defined?; end
  end
end

# bug:true; silent:false
#
# source://cli-kit//lib/cli/kit.rb#87
class CLI::Kit::Bug < ::CLI::Kit::GenericAbort; end

# bug:true; silent:true
#
# source://cli-kit//lib/cli/kit.rb#90
class CLI::Kit::BugSilent < ::CLI::Kit::GenericAbort
  # source://cli-kit//lib/cli/kit.rb#94
  sig { returns(T::Boolean) }
  def silent?; end
end

# source://cli-kit//lib/cli/kit/command_help.rb#7
module CLI::Kit::CommandHelp
  include ::Kernel

  # source://cli-kit//lib/cli/kit/command_help.rb#12
  sig { params(args: T::Array[::String], name: ::String).void }
  def call(args, name); end

  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#45
  sig { params(op: T.untyped, name: ::String).void }
  def invoke(op, name); end

  # use to implement error handling
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#40
  sig { params(op: T.untyped, name: ::String).void }
  def invoke_wrapper(op, name); end

  class << self
    # source://cli-kit//lib/cli/kit/command_help.rb#68
    sig { returns(::Integer) }
    def _max_desc_length; end

    # source://cli-kit//lib/cli/kit/command_help.rb#59
    sig { returns(::String) }
    def _tool_name; end

    # source://cli-kit//lib/cli/kit/command_help.rb#56
    sig { params(max_desc_length: ::Integer).void }
    def max_desc_length=(max_desc_length); end

    # source://cli-kit//lib/cli/kit/command_help.rb#53
    sig { params(tool_name: ::String).void }
    def tool_name=(tool_name); end
  end
end

# source://cli-kit//lib/cli/kit/command_help.rb#73
module CLI::Kit::CommandHelp::ClassMethods
  include ::Kernel

  # source://cli-kit//lib/cli/kit/command_help.rb#107
  sig { returns(::String) }
  def _command_name; end

  # source://cli-kit//lib/cli/kit/command_help.rb#115
  sig { returns(::String) }
  def _desc; end

  # source://cli-kit//lib/cli/kit/command_help.rb#120
  sig { returns(::String) }
  def build_desc; end

  # source://cli-kit//lib/cli/kit/command_help.rb#240
  sig { returns(T.nilable(::String)) }
  def build_examples; end

  # source://cli-kit//lib/cli/kit/command_help.rb#86
  sig { returns(::String) }
  def build_help; end

  # source://cli-kit//lib/cli/kit/command_help.rb#136
  sig { returns(T.nilable(::String)) }
  def build_options; end

  # source://cli-kit//lib/cli/kit/command_help.rb#226
  sig { returns(::String) }
  def build_usage; end

  # source://cli-kit//lib/cli/kit/command_help.rb#188
  sig { params(command_name: ::String).void }
  def command_name(command_name); end

  # source://cli-kit//lib/cli/kit/command_help.rb#197
  sig { params(desc: ::String).void }
  def desc(desc); end

  # source://cli-kit//lib/cli/kit/command_help.rb#264
  sig { params(command: ::String, explanation: T.nilable(::String)).void }
  def example(command, explanation); end

  # source://cli-kit//lib/cli/kit/command_help.rb#183
  sig { params(sections: T::Array[::Symbol]).void }
  def help_sections(sections); end

  # source://cli-kit//lib/cli/kit/command_help.rb#217
  sig { params(long_desc: ::String).void }
  def long_desc(long_desc); end

  # source://cli-kit//lib/cli/kit/command_help.rb#129
  sig { returns(T.untyped) }
  def opts_class; end

  # source://cli-kit//lib/cli/kit/command_help.rb#258
  sig { params(usage: ::String).void }
  def usage(usage); end
end

# source://cli-kit//lib/cli/kit/command_help.rb#77
CLI::Kit::CommandHelp::ClassMethods::DEFAULT_HELP_SECTIONS = T.let(T.unsafe(nil), Array)

# source://cli-kit//lib/cli/kit/command_registry.rb#7
class CLI::Kit::CommandRegistry
  # source://cli-kit//lib/cli/kit/command_registry.rb#60
  sig { params(default: ::String, contextual_resolver: ::CLI::Kit::CommandRegistry::ContextualResolver).void }
  def initialize(default:, contextual_resolver: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#75
  sig do
    params(
      const: T.any(T.class_of(CLI::Kit::BaseCommand), T.proc.returns(T.class_of(CLI::Kit::BaseCommand))),
      name: ::String
    ).void
  end
  def add(const, name); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#86
  sig { params(from: ::String, to: ::String).void }
  def add_alias(from, to); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#18
  sig { returns(T::Hash[::String, ::String]) }
  def aliases; end

  # source://cli-kit//lib/cli/kit/command_registry.rb#91
  sig { returns(T::Array[::String]) }
  def command_names; end

  # source://cli-kit//lib/cli/kit/command_registry.rb#15
  sig do
    returns(T::Hash[::String, T.any(T.class_of(CLI::Kit::BaseCommand), T.proc.returns(T.class_of(CLI::Kit::BaseCommand)))])
  end
  def commands; end

  # source://cli-kit//lib/cli/kit/command_registry.rb#96
  sig { params(name: ::String).returns(T::Boolean) }
  def exist?(name); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#80
  sig { params(name: T.nilable(::String)).returns([T.nilable(T.class_of(CLI::Kit::BaseCommand)), ::String]) }
  def lookup_command(name); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#68
  sig { returns(T::Hash[::String, T.class_of(CLI::Kit::BaseCommand)]) }
  def resolved_commands; end

  private

  # source://cli-kit//lib/cli/kit/command_registry.rb#103
  sig { params(name: ::String).returns(::String) }
  def resolve_alias(name); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#134
  sig do
    params(
      class_or_proc: T.nilable(T.any(T.class_of(CLI::Kit::BaseCommand), T.proc.returns(T.class_of(CLI::Kit::BaseCommand))))
    ).returns(T.nilable(T.class_of(CLI::Kit::BaseCommand)))
  end
  def resolve_class(class_or_proc); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#108
  sig { params(name: ::String).returns([T.nilable(T.class_of(CLI::Kit::BaseCommand)), ::String]) }
  def resolve_command(name); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#126
  sig { params(name: ::String).returns(T.nilable([T.class_of(CLI::Kit::BaseCommand), ::String])) }
  def resolve_contextual_command(name); end

  # source://cli-kit//lib/cli/kit/command_registry.rb#116
  sig { params(name: ::String).returns(T.nilable([T.class_of(CLI::Kit::BaseCommand), ::String])) }
  def resolve_global_command(name); end
end

# source://cli-kit//lib/cli/kit/command_registry.rb#10
CLI::Kit::CommandRegistry::CommandOrProc = T.type_alias { T.any(T.class_of(CLI::Kit::BaseCommand), T.proc.returns(T.class_of(CLI::Kit::BaseCommand))) }

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://cli-kit//lib/cli/kit/command_registry.rb#20
module CLI::Kit::CommandRegistry::ContextualResolver
  interface!

  # @abstract
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#29
  sig { abstract.returns(T::Hash[::String, ::String]) }
  def aliases; end

  # @abstract
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#32
  sig { abstract.params(_name: ::String).returns(T.class_of(CLI::Kit::BaseCommand)) }
  def command_class(_name); end

  # @abstract
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#26
  sig { abstract.returns(T::Array[::String]) }
  def command_names; end
end

# source://cli-kit//lib/cli/kit/command_registry.rb#35
module CLI::Kit::CommandRegistry::NullContextualResolver
  extend ::CLI::Kit::CommandRegistry::ContextualResolver

  class << self
    # source://cli-kit//lib/cli/kit/command_registry.rb#48
    sig { override.returns(T::Hash[::String, ::String]) }
    def aliases; end

    # @raise [CLI::Kit::Abort]
    #
    # source://cli-kit//lib/cli/kit/command_registry.rb#53
    sig { override.params(_name: ::String).returns(T.class_of(CLI::Kit::BaseCommand)) }
    def command_class(_name); end

    # source://cli-kit//lib/cli/kit/command_registry.rb#43
    sig { override.returns(T::Array[::String]) }
    def command_names; end
  end
end

# source://cli-kit//lib/cli/kit/config.rb#8
class CLI::Kit::Config
  # source://cli-kit//lib/cli/kit/config.rb#14
  sig { params(tool_name: ::String).void }
  def initialize(tool_name:); end

  # The path on disk at which the configuration is stored:
  #   `$XDG_CONFIG_HOME/<toolname>/config`
  # if ENV['XDG_CONFIG_HOME'] is not set, we default to ~/.config, e.g.:
  #   ~/.config/tool/config
  #
  # source://cli-kit//lib/cli/kit/config.rb#111
  sig { returns(::String) }
  def file; end

  # Returns the config corresponding to `name` from the config file
  # `false` is returned if it doesn't exist
  #
  # #### Parameters
  # `section` : the section of the config value you are looking for
  # `name` : the name of the config value you are looking for
  #
  # #### Returns
  # `value` : the value of the config variable (nil if none)
  #
  # #### Example Usage
  # `config.get('name.of.config')`
  #
  # source://cli-kit//lib/cli/kit/config.rb#32
  sig { params(section: ::String, name: ::String, default: T.nilable(::String)).returns(T.nilable(::String)) }
  def get(section, name, default: T.unsafe(nil)); end

  # Coalesce and enforce the value of a config to a boolean
  #
  # source://cli-kit//lib/cli/kit/config.rb#38
  sig { params(section: ::String, name: ::String, default: T.nilable(T::Boolean)).returns(T.nilable(T::Boolean)) }
  def get_bool(section, name, default: T.unsafe(nil)); end

  # Gets the hash for the entire section
  #
  # #### Parameters
  # `section` : the section of the config you are getting
  #
  # #### Example Usage
  # `config.get_section('section')`
  #
  # source://cli-kit//lib/cli/kit/config.rb#96
  sig { params(section: ::String).returns(T::Hash[::String, ::String]) }
  def get_section(section); end

  # Sets the config value in the config file
  #
  # #### Parameters
  # `section` : the section of the config you are setting
  # `name` : the name of the config you are setting
  # `value` : the value of the config you are setting
  #
  # #### Example Usage
  # `config.set('section', 'name.of.config', 'value')`
  #
  # source://cli-kit//lib/cli/kit/config.rb#62
  sig { params(section: ::String, name: ::String, value: T.nilable(T.any(::String, T::Boolean))).void }
  def set(section, name, value); end

  # source://cli-kit//lib/cli/kit/config.rb#101
  sig { returns(::String) }
  def to_s; end

  # Unsets a config value in the config file
  #
  # #### Parameters
  # `section` : the section of the config you are deleting
  # `name` : the name of the config you are deleting
  #
  # #### Example Usage
  # `config.unset('section', 'name.of.config')`
  #
  # source://cli-kit//lib/cli/kit/config.rb#83
  sig { params(section: ::String, name: ::String).void }
  def unset(section, name); end

  private

  # source://cli-kit//lib/cli/kit/config.rb#119
  sig { returns(T::Hash[::String, T::Hash[::String, ::String]]) }
  def all_configs; end

  # source://cli-kit//lib/cli/kit/config.rb#124
  sig { returns(::CLI::Kit::Ini) }
  def ini; end

  # source://cli-kit//lib/cli/kit/config.rb#129
  sig { void }
  def write_config; end
end

# source://cli-kit//lib/cli/kit/config.rb#11
CLI::Kit::Config::XDG_CONFIG_HOME = T.let(T.unsafe(nil), String)

# source://cli-kit//lib/cli/kit.rb#33
CLI::Kit::EXIT_BUG = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit.rb#32
CLI::Kit::EXIT_FAILURE_BUT_NOT_BUG = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit.rb#34
CLI::Kit::EXIT_SUCCESS = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit/error_handler.rb#8
class CLI::Kit::ErrorHandler
  # source://cli-kit//lib/cli/kit/error_handler.rb#26
  sig do
    params(
      log_file: T.nilable(::String),
      exception_reporter: T.any(T.class_of(CLI::Kit::ErrorHandler::ExceptionReporter), T.proc.returns(T.class_of(CLI::Kit::ErrorHandler::ExceptionReporter))),
      tool_name: T.nilable(::String),
      dev_mode: T::Boolean
    ).void
  end
  def initialize(log_file: T.unsafe(nil), exception_reporter: T.unsafe(nil), tool_name: T.unsafe(nil), dev_mode: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/error_handler.rb#60
  sig { params(block: T.proc.void).returns(::Integer) }
  def call(&block); end

  # source://cli-kit//lib/cli/kit/error_handler.rb#16
  sig { params(override_exception_handler: T.proc.params(arg0: ::Exception).returns(::Integer)).void }
  def override_exception_handler=(override_exception_handler); end

  # source://cli-kit//lib/cli/kit/error_handler.rb#68
  sig { params(error: T.nilable(::Exception)).void }
  def report_exception(error); end

  private

  # source://cli-kit//lib/cli/kit/error_handler.rb#134
  sig { params(error: T.nilable(::Exception)).returns(T.nilable(::Exception)) }
  def exception_for_submission(error); end

  # source://cli-kit//lib/cli/kit/error_handler.rb#172
  sig { returns(T.class_of(CLI::Kit::ErrorHandler::ExceptionReporter)) }
  def exception_reporter; end

  # source://cli-kit//lib/cli/kit/error_handler.rb#165
  sig { params(message: ::String).void }
  def stderr_puts(message); end

  # Run the program, handling any errors that occur.
  #
  # Errors are printed to stderr unless they're #silent?, and are reported
  # to bugsnag (by setting @at_exit_exeption for our at_exit handler) if
  # they're #bug?
  #
  # Returns an exit status for the program.
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#96
  sig { params(block: T.proc.void).returns(::Integer) }
  def triage_all_exceptions(&block); end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://cli-kit//lib/cli/kit/error_handler.rb#33
class CLI::Kit::ErrorHandler::ExceptionReporter
  abstract!

  class << self
    # @abstract
    #
    # source://cli-kit//lib/cli/kit/error_handler.rb#42
    sig { abstract.params(exception: T.nilable(::Exception), logs: T.nilable(::String)).void }
    def report(exception, logs = T.unsafe(nil)); end
  end
end

# source://cli-kit//lib/cli/kit/error_handler.rb#11
CLI::Kit::ErrorHandler::ExceptionReporterOrProc = T.type_alias { T.any(T.class_of(CLI::Kit::ErrorHandler::ExceptionReporter), T.proc.returns(T.class_of(CLI::Kit::ErrorHandler::ExceptionReporter))) }

# source://cli-kit//lib/cli/kit/error_handler.rb#46
class CLI::Kit::ErrorHandler::NullExceptionReporter < ::CLI::Kit::ErrorHandler::ExceptionReporter
  class << self
    # source://cli-kit//lib/cli/kit/error_handler.rb#53
    sig { override.params(_exception: T.nilable(::Exception), _logs: T.nilable(::String)).void }
    def report(_exception, _logs = T.unsafe(nil)); end
  end
end

# source://cli-kit//lib/cli/kit/error_handler.rb#82
CLI::Kit::ErrorHandler::SIGNALS_THAT_ARENT_BUGS = T.let(T.unsafe(nil), Array)

# source://cli-kit//lib/cli/kit/executor.rb#9
class CLI::Kit::Executor
  # source://cli-kit//lib/cli/kit/executor.rb#13
  sig { params(log_file: ::String).void }
  def initialize(log_file:); end

  # source://cli-kit//lib/cli/kit/executor.rb#19
  sig { params(command: T.class_of(CLI::Kit::BaseCommand), command_name: ::String, args: T::Array[::String]).void }
  def call(command, command_name, args); end

  private

  # source://cli-kit//lib/cli/kit/executor.rb#92
  sig { params(_sig: T.untyped).void }
  def info_handler(_sig); end

  # source://cli-kit//lib/cli/kit/executor.rb#82
  sig { params(_sig: T.untyped).void }
  def quit_handler(_sig); end

  # source://cli-kit//lib/cli/kit/executor.rb#63
  sig do
    type_parameters(:T)
      .params(
        signal: ::String,
        handler: ::Method,
        block: T.proc.returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def twrap(signal, handler, &block); end

  # source://cli-kit//lib/cli/kit/executor.rb#43
  sig do
    type_parameters(:T)
      .params(
        block: T.proc.params(id: ::String).returns(T.type_parameter(:T))
      ).returns(T.type_parameter(:T))
  end
  def with_logging(&block); end

  # source://cli-kit//lib/cli/kit/executor.rb#52
  sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
  def with_traps(&block); end
end

# Abort, Bug, AbortSilent, and BugSilent are four ways of immediately bailing
# on command-line execution when an unrecoverable error occurs.
#
# Note that these don't inherit from StandardError, and so are not caught by
# a bare `rescue => e`.
#
# * Abort prints its message in red and exits 1;
# * Bug additionally submits the exception to the exception_reporter passed to
#     `CLI::Kit::ErrorHandler.new`
# * AbortSilent and BugSilent do the same as above, but do not print
#     messages before exiting.
#
# Treat these like panic() in Go:
#   * Don't rescue them. Use a different Exception class if you plan to recover;
#   * Provide a useful message, since it will be presented in brief to the
#       user, and will be useful for debugging.
#   * Avoid using it if it does actually make sense to recover from an error.
#
# Additionally:
#   * Do not subclass these.
#   * Only use AbortSilent or BugSilent if you prefer to print a more
#       contextualized error than Abort or Bug would present to the user.
#   * In general, don't attach a message to AbortSilent or BugSilent.
#   * Never raise GenericAbort directly.
#   * Think carefully about whether Abort or Bug is more appropriate. Is this
#       a bug in the tool? Or is it just user error, transient network
#       failure, etc.?
#   * One case where it's ok to rescue (cli-kit internals or tests aside):
#       1. rescue Abort or Bug
#       2. Print a contextualized error message
#       3. Re-raise AbortSilent or BugSilent respectively.
#
# These aren't the only exceptions that can carry this 'bug' and 'silent'
# metadata, however:
#
# If you raise an exception with `CLI::Kit.raise(..., bug: x, silent: y)`,
# those last two (optional) keyword arguments will attach the metadata to
# whatever exception you raise. This is interpreted later in the
# ErrorHandler to decide how to print output and whether to submit the
# exception to bugsnag.
#
# source://cli-kit//lib/cli/kit.rb#76
class CLI::Kit::GenericAbort < ::Exception; end

# INI is a language similar to JSON or YAML, but simplied
# The spec is here: https://en.wikipedia.org/wiki/INI_file
# This parser includes supports for 2 very basic uses
# - Sections
# - Key Value Pairs (within and outside of the sections)
#
# [global]
# key = val
#
# Nothing else is supported right now
# See the ini_test.rb file for more examples
#
# source://cli-kit//lib/cli/kit/ini.rb#19
class CLI::Kit::Ini
  # source://cli-kit//lib/cli/kit/ini.rb#28
  sig { params(path: T.nilable(::String), config: T.nilable(::String), default_section: ::String).void }
  def initialize(path = T.unsafe(nil), config: T.unsafe(nil), default_section: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/ini.rb#57
  sig { returns(::String) }
  def git_format; end

  # source://cli-kit//lib/cli/kit/ini.rb#23
  sig { returns(T::Hash[::String, T::Hash[::String, ::String]]) }
  def ini; end

  # @return [Hash{String => Hash{String => String}}]
  #
  # source://cli-kit//lib/cli/kit/ini.rb#23
  def ini=(_arg0); end

  # source://cli-kit//lib/cli/kit/ini.rb#39
  sig { returns(T::Hash[::String, T::Hash[::String, ::String]]) }
  def parse; end

  # source://cli-kit//lib/cli/kit/ini.rb#62
  sig { returns(::String) }
  def to_s; end

  private

  # source://cli-kit//lib/cli/kit/ini.rb#90
  sig { params(k: ::String).returns(T::Boolean) }
  def section_designator?(k); end

  # source://cli-kit//lib/cli/kit/ini.rb#83
  sig { params(key: ::String, val: ::String).void }
  def set_val(key, val); end

  # source://cli-kit//lib/cli/kit/ini.rb#69
  sig { params(git_format: T::Boolean).returns(::String) }
  def to_ini(git_format: T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/levenshtein.rb#30
module CLI::Kit::Levenshtein
  private

  # source://cli-kit//lib/cli/kit/levenshtein.rb#38
  sig { params(str1: ::String, str2: ::String).returns(::Integer) }
  def distance(str1, str2); end

  # detects the minimum value out of three arguments. This method is
  # faster than `[a, b, c].min` and puts less GC pressure.
  # See https://github.com/yuki24/did_you_mean/pull/1 for a performance
  # benchmark.
  #
  # source://cli-kit//lib/cli/kit/levenshtein.rb#78
  sig { params(a: ::Integer, b: ::Integer, c: ::Integer).returns(::Integer) }
  def min3(a, b, c); end

  class << self
    # source://sorbet-runtime/0.5.12414/lib/types/private/methods/_methods.rb#257
    def distance(*args, **_arg1, &blk); end

    # detects the minimum value out of three arguments. This method is
    # faster than `[a, b, c].min` and puts less GC pressure.
    # See https://github.com/yuki24/did_you_mean/pull/1 for a performance
    # benchmark.
    #
    # @param a [Integer]
    # @param b [Integer]
    # @param c [Integer]
    # @return [Integer]
    #
    # source://sorbet-runtime/0.5.12414/lib/types/private/methods/_methods.rb#257
    def min3(*args, **_arg1, &blk); end
  end
end

# source://cli-kit//lib/cli/kit/logger.rb#9
class CLI::Kit::Logger
  # Constructor for CLI::Kit::Logger
  #
  # source://cli-kit//lib/cli/kit/logger.rb#19
  sig { params(debug_log_file: ::String, env_debug_name: ::String).void }
  def initialize(debug_log_file:, env_debug_name: T.unsafe(nil)); end

  # Similar to Logger#debug, however will not output to STDOUT unless DEBUG env var is set
  # Logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # source://cli-kit//lib/cli/kit/logger.rb#74
  sig { params(msg: ::String).void }
  def debug(msg); end

  # Functionally equivalent to Logger#error
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # source://cli-kit//lib/cli/kit/logger.rb#53
  sig { params(msg: ::String, debug: T::Boolean).void }
  def error(msg, debug: T.unsafe(nil)); end

  # Functionally equivalent to Logger#fatal
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # source://cli-kit//lib/cli/kit/logger.rb#64
  sig { params(msg: ::String, debug: T::Boolean).void }
  def fatal(msg, debug: T.unsafe(nil)); end

  # Functionally equivalent to Logger#info
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # source://cli-kit//lib/cli/kit/logger.rb#31
  sig { params(msg: ::String, debug: T::Boolean).void }
  def info(msg, debug: T.unsafe(nil)); end

  # Functionally equivalent to Logger#warn
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # source://cli-kit//lib/cli/kit/logger.rb#42
  sig { params(msg: ::String, debug: T::Boolean).void }
  def warn(msg, debug: T.unsafe(nil)); end

  private

  # source://cli-kit//lib/cli/kit/logger.rb#90
  sig { returns(T::Boolean) }
  def debug?; end

  # source://cli-kit//lib/cli/kit/logger.rb#82
  sig { params(msg: ::String).returns(::String) }
  def format_debug(msg); end
end

# 5MB
#
# source://cli-kit//lib/cli/kit/logger.rb#12
CLI::Kit::Logger::MAX_LOG_SIZE = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit/logger.rb#13
CLI::Kit::Logger::MAX_NUM_LOGS = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit/opts.rb#7
class CLI::Kit::Opts
  include ::CLI::Kit::Opts::Mixin
  extend ::CLI::Kit::Opts::Mixin::MixinClassMethods

  # source://cli-kit//lib/cli/kit/opts.rb#250
  sig { params(name: ::String).returns(T.nilable(T.any(::String, T::Boolean))) }
  def [](name); end

  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#277
  sig { returns(::CLI::Kit::Args::Evaluation) }
  def assert_result!; end

  # source://cli-kit//lib/cli/kit/opts.rb#284
  sig { params(defn: ::CLI::Kit::Args::Definition).void }
  def define!(defn); end

  # source://cli-kit//lib/cli/kit/opts.rb#238
  sig { params(block: T.nilable(T.proc.params(arg0: ::Symbol, arg1: T::Boolean).void)).returns(T.untyped) }
  def each_flag(&block); end

  # source://cli-kit//lib/cli/kit/opts.rb#220
  sig { params(block: T.nilable(T.proc.params(arg0: ::Symbol, arg1: T.nilable(::String)).void)).returns(T.untyped) }
  def each_option(&block); end

  # source://cli-kit//lib/cli/kit/opts.rb#295
  sig { params(ev: ::CLI::Kit::Args::Evaluation).void }
  def evaluate!(ev); end

  # source://cli-kit//lib/cli/kit/opts.rb#203
  sig { returns(T::Boolean) }
  def helpflag; end

  # source://cli-kit//lib/cli/kit/opts.rb#269
  sig { params(name: ::String).returns(T::Boolean) }
  def lookup_flag(name); end

  # source://cli-kit//lib/cli/kit/opts.rb#260
  sig { params(name: ::String).returns(T.nilable(::String)) }
  def lookup_option(name); end

  # source://cli-kit//lib/cli/kit/opts.rb#208
  sig { returns(T::Array[::String]) }
  def unparsed; end
end

# source://cli-kit//lib/cli/kit/opts.rb#200
CLI::Kit::Opts::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Array)

# source://cli-kit//lib/cli/kit/opts.rb#10
module CLI::Kit::Opts::Mixin
  include ::Kernel

  mixes_in_class_methods ::CLI::Kit::Opts::Mixin::MixinClassMethods

  # source://cli-kit//lib/cli/kit/opts.rb#127
  sig do
    params(
      name: ::Symbol,
      short: T.nilable(::String),
      long: T.nilable(::String),
      desc: T.nilable(::String)
    ).returns(T::Boolean)
  end
  def flag(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/opts.rb#107
  sig do
    params(
      name: ::Symbol,
      short: T.nilable(::String),
      long: T.nilable(::String),
      desc: T.nilable(::String),
      default: T.any(T.proc.returns(T::Array[::String]), T::Array[::String])
    ).returns(T::Array[::String])
  end
  def multi_option(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/opts.rb#61
  sig do
    params(
      name: ::Symbol,
      short: T.nilable(::String),
      long: T.nilable(::String),
      desc: T.nilable(::String),
      default: T.nilable(T.any(::String, T.proc.returns(::String)))
    ).returns(T.nilable(::String))
  end
  def option(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/opts.rb#86
  sig do
    params(
      name: ::Symbol,
      short: T.nilable(::String),
      long: T.nilable(::String),
      desc: T.nilable(::String),
      default: T.nilable(T.any(::String, T.proc.returns(::String)))
    ).returns(::String)
  end
  def option!(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/opts.rb#160
  sig do
    params(
      name: ::Symbol,
      desc: T.nilable(::String),
      default: T.nilable(T.any(::String, T.proc.returns(::String))),
      skip: T.nilable(T.any(T.proc.returns(T::Boolean), T.proc.params(arg0: ::String).returns(T::Boolean)))
    ).returns(T.nilable(::String))
  end
  def position(name: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil), skip: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/opts.rb#138
  sig { params(name: ::Symbol, desc: T.nilable(::String)).returns(::String) }
  def position!(name: T.unsafe(nil), desc: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/opts.rb#171
  sig { params(name: ::Symbol, desc: T.nilable(::String)).returns(T::Array[::String]) }
  def rest(name: T.unsafe(nil), desc: T.unsafe(nil)); end

  private

  # @raise [ArgumentError]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#184
  sig { returns(::Symbol) }
  def infer_name; end

  class << self
    # source://cli-kit//lib/cli/kit/opts.rb#47
    sig { params(klass: ::Module).void }
    def included(klass); end
  end
end

# source://cli-kit//lib/cli/kit/opts.rb#14
module CLI::Kit::Opts::Mixin::MixinClassMethods
  # source://cli-kit//lib/cli/kit/opts.rb#18
  sig { params(included_module: ::Module).void }
  def include(included_module); end

  # No signature - Sorbet uses method_added internally, so can't verify it
  #
  # source://cli-kit//lib/cli/kit/opts.rb#26
  def method_added(method_name); end

  # source://cli-kit//lib/cli/kit/opts.rb#32
  sig { params(method_name: ::Symbol).void }
  def track_method(method_name); end

  # source://cli-kit//lib/cli/kit/opts.rb#38
  sig { returns(T::Array[::Symbol]) }
  def tracked_methods; end
end

# source://cli-kit//lib/cli/kit/parse_args.rb#5
module CLI::Kit::ParseArgs
  include ::Kernel

  # T.untyped is used in two places. The interpretation of dynamic values from the provided `opts`
  # and the resulting args[:opts] is pretty broad. There seems to be minimal value in expressing a
  # tighter subset of T.untyped.
  #
  # source://cli-kit//lib/cli/kit/parse_args.rb#16
  sig do
    params(
      args: ::String,
      opts_defn: T::Hash[::Symbol, T::Array[T.untyped]]
    ).returns(T::Hash[::Symbol, T.untyped])
  end
  def parse_args(args, opts_defn); end
end

# source://cli-kit//lib/cli/kit/resolver.rb#7
class CLI::Kit::Resolver
  # source://cli-kit//lib/cli/kit/resolver.rb#11
  sig { params(tool_name: ::String, command_registry: ::CLI::Kit::CommandRegistry).void }
  def initialize(tool_name:, command_registry:); end

  # source://cli-kit//lib/cli/kit/resolver.rb#17
  sig { params(args: T::Array[::String]).returns([T.class_of(CLI::Kit::BaseCommand), ::String, T::Array[::String]]) }
  def call(args); end

  private

  # source://cli-kit//lib/cli/kit/resolver.rb#34
  sig { params(name: T.nilable(::String)).void }
  def command_not_found(name); end

  # source://cli-kit//lib/cli/kit/resolver.rb#63
  sig { returns(T::Array[::String]) }
  def commands_and_aliases; end
end

# source://cli-kit//lib/cli/kit/support.rb#7
module CLI::Kit::Support; end

# source://cli-kit//lib/cli/kit/support/test_helper.rb#6
module CLI::Kit::Support::TestHelper
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#12
  def assert_all_commands_run(should_raise: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/support/test_helper.rb#7
  def setup; end

  # source://cli-kit//lib/cli/kit/support/test_helper.rb#21
  def teardown; end
end

# source://cli-kit//lib/cli/kit/support/test_helper.rb#28
module CLI::Kit::Support::TestHelper::FakeConfig
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#32
  def setup; end

  # source://cli-kit//lib/cli/kit/support/test_helper.rb#39
  def teardown; end
end

# source://cli-kit//lib/cli/kit/support/test_helper.rb#46
class CLI::Kit::Support::TestHelper::FakeSuccess
  # @return [FakeSuccess] a new instance of FakeSuccess
  #
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#47
  def initialize(success); end

  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#51
  def success?; end
end

# source://cli-kit//lib/cli/kit/system.rb#9
module CLI::Kit::System
  class << self
    # Execute a command in the user's environment
    # This is meant to be largely equivalent to backticks, only with the env passed in.
    # Captures the results of the command without output to the console
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional arguments to pass to Open3.capture2
    #
    # #### Returns
    # - `output`: output (STDOUT) of the command execution
    # - `status`: boolean success status of the command execution
    #
    # #### Usage
    # `out, stat = CLI::Kit::System.capture2('ls', 'a_folder')`
    #
    # source://cli-kit//lib/cli/kit/system.rb#61
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        kwargs: T.untyped
      ).returns([::String, ::Process::Status])
    end
    def capture2(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # Execute a command in the user's environment
    # This is meant to be largely equivalent to backticks, only with the env passed in.
    # Captures the results of the command without output to the console
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional arguments to pass to Open3.capture2e
    #
    # #### Returns
    # - `output`: output (STDOUT merged with STDERR) of the command execution
    # - `status`: boolean success status of the command execution
    #
    # #### Usage
    # `out_and_err, stat = CLI::Kit::System.capture2e('ls', 'a_folder')`
    #
    # source://cli-kit//lib/cli/kit/system.rb#92
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        kwargs: T.untyped
      ).returns([::String, ::Process::Status])
    end
    def capture2e(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # Execute a command in the user's environment
    # This is meant to be largely equivalent to backticks, only with the env passed in.
    # Captures the results of the command without output to the console
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional arguments to pass to Open3.capture3
    #
    # #### Returns
    # - `output`: STDOUT of the command execution
    # - `error`: STDERR of the command execution
    # - `status`: boolean success status of the command execution
    #
    # #### Usage
    # `out, err, stat = CLI::Kit::System.capture3('ls', 'a_folder')`
    #
    # source://cli-kit//lib/cli/kit/system.rb#124
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        kwargs: T.untyped
      ).returns([::String, ::String, ::Process::Status])
    end
    def capture3(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # Returns the errors associated to a test run
    #
    # #### Returns
    # `errors` (String) a string representing errors found on this run, nil if none
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#178
    def error_message; end

    # Sets up an expectation for a command and stubs out the call (unless allow is true)
    #
    # #### Parameters
    # `*a` : the command, represented as a splat
    # `stdout` : stdout to stub the command with (defaults to empty string)
    # `stderr` : stderr to stub the command with (defaults to empty string)
    # `allow` : allow determines if the command will be actually run, or stubbed. Defaults to nil (stub)
    # `success` : success status to stub the command with (Defaults to nil)
    # `sudo` : expectation of sudo being set or not (defaults to false)
    # `env` : expectation of env being set or not (defaults to {})
    #
    # Note: Must set allow or success
    #
    # @raise [ArgumentError]
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#147
    def fake(*a, stdout: T.unsafe(nil), stderr: T.unsafe(nil), allow: T.unsafe(nil), success: T.unsafe(nil), sudo: T.unsafe(nil), env: T.unsafe(nil)); end

    # source://sorbet-runtime/0.5.12414/lib/types/private/methods/_methods.rb#257
    def original_capture2(*args, **_arg1, &blk); end

    # source://sorbet-runtime/0.5.12414/lib/types/private/methods/_methods.rb#257
    def original_capture2e(*args, **_arg1, &blk); end

    # source://sorbet-runtime/0.5.12414/lib/types/private/methods/_methods.rb#257
    def original_capture3(*args, **_arg1, &blk); end

    # source://sorbet-runtime/0.5.12414/lib/types/private/methods/_methods.rb#257
    def original_system(*args, **_arg1, &blk); end

    # source://cli-kit//lib/cli/kit/system.rb#300
    sig { returns(::Symbol) }
    def os; end

    # source://cli-kit//lib/cli/kit/system.rb#142
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        kwargs: T.untyped,
        block: T.nilable(T.proc.params(stdin: ::IO, stdout: ::IO, wait_thr: ::Process::Waiter).returns([::IO, ::IO, ::Process::Waiter]))
      ).returns([::IO, ::IO, ::Process::Waiter])
    end
    def popen2(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

    # source://cli-kit//lib/cli/kit/system.rb#160
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        kwargs: T.untyped,
        block: T.nilable(T.proc.params(stdin: ::IO, stdout: ::IO, wait_thr: ::Process::Waiter).returns([::IO, ::IO, ::Process::Waiter]))
      ).returns([::IO, ::IO, ::Process::Waiter])
    end
    def popen2e(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

    # source://cli-kit//lib/cli/kit/system.rb#178
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        kwargs: T.untyped,
        block: T.nilable(T.proc.params(stdin: ::IO, stdout: ::IO, stderr: ::IO, wait_thr: ::Process::Waiter).returns([::IO, ::IO, ::IO, ::Process::Waiter]))
      ).returns([::IO, ::IO, ::IO, ::Process::Waiter])
    end
    def popen3(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

    # Resets the faked commands
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#170
    def reset!; end

    # Split off trailing partial UTF-8 Characters. UTF-8 Multibyte characters start with a 11xxxxxx byte that tells
    # how many following bytes are part of this character, followed by some number of 10xxxxxx bytes.  This simple
    # algorithm will split off a whole trailing multi-byte character.
    #
    # source://cli-kit//lib/cli/kit/system.rb#264
    sig { params(data: ::String).returns([::String, ::String]) }
    def split_partial_characters(data); end

    # Ask for sudo access with a message explaning the need for it
    # Will make subsequent commands capable of running with sudo for a period of time
    #
    # #### Parameters
    # - `msg`: A message telling the user why sudo is needed
    #
    # #### Usage
    # `ctx.sudo_reason("We need to do a thing")`
    #
    # source://cli-kit//lib/cli/kit/system.rb#24
    sig { params(msg: ::String).void }
    def sudo_reason(msg); end

    # Execute a command in the user's environment
    # Outputs result of the command without capturing it
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional keyword arguments to pass to Process.spawn
    #
    # #### Returns
    # - `status`: The `Process:Status` result for the command execution
    #
    # #### Usage
    # `stat = CLI::Kit::System.system('ls', 'a_folder')`
    #
    # source://cli-kit//lib/cli/kit/system.rb#209
    sig do
      params(
        cmd: ::String,
        args: ::String,
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        stdin: T.nilable(T.any(::IO, ::Integer, ::String, ::Symbol)),
        kwargs: T.untyped,
        block: T.nilable(T.proc.params(out: ::String, err: ::String).void)
      ).returns(::Process::Status)
    end
    def system(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), stdin: T.unsafe(nil), **kwargs, &block); end

    # source://cli-kit//lib/cli/kit/system.rb#309
    sig { params(cmd: ::String, env: T::Hash[::String, T.nilable(::String)]).returns(T.nilable(::String)) }
    def which(cmd, env); end

    private

    # source://cli-kit//lib/cli/kit/system.rb#327
    sig do
      params(
        cmd: ::String,
        args: T::Array[::String],
        sudo: T.any(::String, T::Boolean)
      ).returns([::String, T::Array[::String]])
    end
    def apply_sudo(cmd, args, sudo); end

    # source://cli-kit//lib/cli/kit/system.rb#345
    sig do
      params(
        cmd: ::String,
        args: T::Array[::String],
        kwargs: T::Hash[::Symbol, T.untyped],
        sudo: T.any(::String, T::Boolean),
        env: T::Hash[::String, T.nilable(::String)],
        method: ::Symbol,
        block: T.untyped
      ).returns(T.untyped)
    end
    def delegate_open3(cmd, args, kwargs, sudo: T.unsafe(nil), env: T.unsafe(nil), method: T.unsafe(nil), &block); end

    # source://cli-kit//lib/cli/kit/support/test_helper.rb#235
    def expected_command(a, sudo: T.unsafe(nil), env: T.unsafe(nil)); end

    # Ruby resolves the program to execute using its own PATH, but we want it to
    # use the provided one, so we ensure ruby chooses to spawn a shell, which will
    # parse our command and properly spawn our target using the provided environment.
    #
    # This is important because dev clobbers its own environment such that ruby
    # means /usr/bin/ruby, but we want it to select the ruby targeted by the active
    # project.
    #
    # See https://github.com/Shopify/dev/pull/625 for more details.
    #
    # source://cli-kit//lib/cli/kit/system.rb#366
    sig do
      params(
        cmd: ::String,
        args: T::Array[::String],
        env: T::Hash[::String, T.nilable(::String)]
      ).returns([::String, T::Array[::String]])
    end
    def resolve_path(cmd, args, env); end
  end
end

# source://cli-kit//lib/cli/kit/system.rb#10
CLI::Kit::System::SUDO_PROMPT = T.let(T.unsafe(nil), String)

# source://cli-kit//lib/cli/kit/util.rb#7
module CLI::Kit::Util
  class << self
    # Must call retry_after on the result in order to execute the block
    #
    # Example usage:
    #
    # CLI::Kit::Util.begin do
    #   might_raise_if_costly_prep_not_done()
    # end.retry_after(ExpectedError) do
    #   costly_prep()
    # end
    #
    # source://cli-kit//lib/cli/kit/util.rb#92
    sig do
      type_parameters(:T)
        .params(
          block_that_might_raise: T.proc.returns(T.type_parameter(:T))
        ).returns(CLI::Kit::Util::Retrier[T.type_parameter(:T)])
    end
    def begin(&block_that_might_raise); end

    # Converts an integer representing bytes into a human readable format
    #
    # source://cli-kit//lib/cli/kit/util.rb#14
    sig { params(bytes: ::Integer, precision: ::Integer, space: T::Boolean).returns(::String) }
    def to_filesize(bytes, precision: T.unsafe(nil), space: T.unsafe(nil)); end

    # Converts a number to a human readable format on the SI scale
    #
    # @raise [ArgumentError]
    #
    # source://cli-kit//lib/cli/kit/util.rb#24
    sig do
      params(
        number: ::Numeric,
        unit: ::String,
        factor: ::Integer,
        precision: ::Integer,
        space: T::Boolean
      ).returns(::String)
    end
    def to_si_scale(number, unit = T.unsafe(nil), factor: T.unsafe(nil), precision: T.unsafe(nil), space: T.unsafe(nil)); end

    # Dir.chdir, when invoked in block form, complains when we call chdir
    # again recursively. There's no apparent good reason for this, so we
    # simply implement our own block form of Dir.chdir here.
    #
    # source://cli-kit//lib/cli/kit/util.rb#69
    sig do
      type_parameters(:T)
        .params(
          dir: ::String,
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_dir(dir, &block); end
  end
end

# source://cli-kit//lib/cli/kit/util.rb#97
class CLI::Kit::Util::Retrier
  extend T::Generic

  BlockReturnType = type_member

  # source://cli-kit//lib/cli/kit/util.rb#104
  sig { params(block_that_might_raise: T.proc.returns(BlockReturnType)).void }
  def initialize(block_that_might_raise); end

  # source://cli-kit//lib/cli/kit/util.rb#115
  sig do
    params(
      exception: T.class_of(Exception),
      retries: ::Integer,
      before_retry: T.nilable(T.proc.params(e: ::Exception).void)
    ).returns(BlockReturnType)
  end
  def retry_after(exception = T.unsafe(nil), retries: T.unsafe(nil), &before_retry); end
end

# source://cli-kit//lib/cli/kit/core_ext.rb#4
class Exception
  # You'd think instance variables @bug and @silent would work here. They
  # don't. I'm not sure why. If you, the reader, want to take some time to
  # figure it out, go ahead and refactor to that.
  #
  # source://cli-kit//lib/cli/kit/core_ext.rb#12
  sig { returns(T::Boolean) }
  def bug?; end

  # source://cli-kit//lib/cli/kit/core_ext.rb#17
  sig { returns(T::Boolean) }
  def silent?; end
end

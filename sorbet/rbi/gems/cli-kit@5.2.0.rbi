# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-kit` gem.
# Please instead update this file by running `bin/tapioca gem cli-kit`.


# source://cli-kit//lib/cli/kit.rb#6
module CLI; end

# source://cli-kit//lib/cli/kit.rb#7
module CLI::Kit
  class << self
    # Mirrors the API of Kernel#raise, but with the addition of a few new
    # optional keyword arguments. `bug` and `silent` attach metadata to the
    # exception being raised, which is interpreted later in the ErrorHandler to
    # decide what to print and whether to submit to bugsnag.
    #
    # `depth` is used to trim leading elements of the backtrace. If you wrap
    # this method in your own wrapper, you'll want to pass `depth: 2`, for
    # example.
    # : (?(Class | String | Exception) exception, ?untyped string, ?Array[String]? array, ?cause: Exception?, ?bug: bool?, ?silent: bool?, ?depth: Integer) -> bot
    #
    # source://cli-kit//lib/cli/kit.rb#113
    def raise(exception = T.unsafe(nil), string = T.unsafe(nil), array = T.unsafe(nil), cause: T.unsafe(nil), bug: T.unsafe(nil), silent: T.unsafe(nil), depth: T.unsafe(nil)); end
  end
end

# bug:false; silent: false
#
# source://cli-kit//lib/cli/kit.rb#74
class CLI::Kit::Abort < ::CLI::Kit::GenericAbort
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit.rb#76
  def bug?; end
end

# bug:false; silent:true
#
# source://cli-kit//lib/cli/kit.rb#91
class CLI::Kit::AbortSilent < ::CLI::Kit::GenericAbort
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit.rb#93
  def bug?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit.rb#98
  def silent?; end
end

# source://cli-kit//lib/cli/kit/args.rb#7
module CLI::Kit::Args; end

# source://cli-kit//lib/cli/kit/args/definition.rb#8
class CLI::Kit::Args::Definition
  # : -> void
  #
  # @return [Definition] a new instance of Definition
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#55
  def initialize; end

  # : (Symbol name, ?short: String?, ?long: String?, ?desc: String?) -> void
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#25
  def add_flag(name, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil)); end

  # : (Symbol name, ?short: String?, ?long: String?, ?desc: String?, ?default: (String | ^-> String | Array[String] | ^-> Array[String])?, ?required: bool, ?multi: bool) -> void
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#33
  def add_option(name, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil), required: T.unsafe(nil), multi: T.unsafe(nil)); end

  # : (Symbol name, required: bool, multi: bool, ?desc: String?, ?default: (String | ^-> String)?, ?skip: (^-> bool | ^(String arg0) -> bool)?) -> void
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#44
  def add_position(name, required:, multi:, desc: T.unsafe(nil), default: T.unsafe(nil), skip: T.unsafe(nil)); end

  # : Array[Flag]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#16
  def flags; end

  # : (Symbol name) -> Flag?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#179
  def lookup_flag(name); end

  # : (String name) -> (Flag | Option)?
  #
  # @raise [InvalidLookup]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#202
  def lookup_long(name); end

  # : (Symbol name) -> Option?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#187
  def lookup_option(name); end

  # : (Symbol name) -> Position?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#209
  def lookup_position(name); end

  # : (String name) -> (Flag | Option)?
  #
  # @raise [InvalidLookup]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#195
  def lookup_short(name); end

  # : Array[Option]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#19
  def options; end

  # : Array[Position]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#22
  def positions; end

  private

  # : ((Flag | Position) arg) -> void
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#276
  def add_name_resolution(arg); end

  # : (Flag flagopt) -> void
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#257
  def add_resolution(flagopt); end

  # : (String long) -> String
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#236
  def strip_long_prefix(long); end

  # : (String? short, String? long) -> [String?, String?]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#245
  def strip_prefixes_and_validate(short, long); end

  # : (String short) -> String
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#224
  def strip_short_prefix(short); end

  # : (Position position) -> void
  #
  # @raise [InvalidPosition]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#219
  def validate_order(position); end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#10
class CLI::Kit::Args::Definition::ConflictingFlag < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#9
class CLI::Kit::Args::Definition::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#103
class CLI::Kit::Args::Definition::Flag
  include ::CLI::Kit::Args::Definition::OptBase

  # : (name: Symbol, ?short: String?, ?long: String?, ?desc: String?) -> void
  #
  # @return [Flag] a new instance of Flag
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#118
  def initialize(name:, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil)); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#113
  def as_written_by_user; end

  # : String?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#110
  def long; end

  # : String?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#107
  def short; end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#11
class CLI::Kit::Args::Definition::InvalidFlag < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#12
class CLI::Kit::Args::Definition::InvalidLookup < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#13
class CLI::Kit::Args::Definition::InvalidPosition < ::CLI::Kit::Args::Definition::Error; end

# source://cli-kit//lib/cli/kit/args/definition.rb#64
module CLI::Kit::Args::Definition::OptBase
  # : String?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#69
  def desc; end

  # : Symbol
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#66
  def name; end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#72
module CLI::Kit::Args::Definition::OptValue
  # : -> (String | Array[String])?
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#74
  def default; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#83
  def dynamic_default?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#93
  def multi?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#98
  def optional?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#88
  def required?; end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#162
class CLI::Kit::Args::Definition::Option < ::CLI::Kit::Args::Definition::Flag
  include ::CLI::Kit::Args::Definition::OptValue

  # : (name: Symbol, ?short: String?, ?long: String?, ?desc: String?, ?default: (String | ^-> String | Array[String] | ^-> Array[String])?, ?required: bool, ?multi: bool) -> void
  #
  # @return [Option] a new instance of Option
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#166
  def initialize(name:, short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil), required: T.unsafe(nil), multi: T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/definition.rb#130
class CLI::Kit::Args::Definition::Position
  include ::CLI::Kit::Args::Definition::OptBase
  include ::CLI::Kit::Args::Definition::OptValue

  # : (name: Symbol, desc: String?, required: bool, multi: bool, ?default: (String | ^-> String)?, ?skip: (^-> bool | ^(String arg0) -> bool)?) -> void
  #
  # @return [Position] a new instance of Position
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#135
  def initialize(name:, desc:, required:, multi:, default: T.unsafe(nil), skip: T.unsafe(nil)); end

  # : (String arg) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/definition.rb#149
  def skip?(arg); end
end

# source://cli-kit//lib/cli/kit/args.rb#8
class CLI::Kit::Args::Error < ::StandardError; end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#8
class CLI::Kit::Args::Evaluation
  # : (Definition defn, Array[Parser::Node] parse) -> void
  #
  # @return [Evaluation] a new instance of Evaluation
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#128
  def initialize(defn, parse); end

  # : -> void
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#135
  def check_required_options!; end

  # : Definition
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#114
  def defn; end

  # : -> FlagProxy
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#99
  def flag; end

  # : (Definition::Flag flag) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#175
  def lookup_flag(flag); end

  # : (Definition::Option opt) -> (String | Array[String])?
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#188
  def lookup_option(opt); end

  # : (Definition::Position position) -> (String | Array[String])?
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#199
  def lookup_position(position); end

  # : -> OptionProxy
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#104
  def opt; end

  # : Array[Parser::Node]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#117
  def parse; end

  # : -> PositionProxy
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#109
  def position; end

  # : -> void
  #
  # @raise [TooManyPositions]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#154
  def resolve_positions!; end

  # : -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#120
  def unparsed; end

  private

  # : -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#206
  def args; end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#9
class CLI::Kit::Args::Evaluation::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#32
class CLI::Kit::Args::Evaluation::FlagProxy
  # : (Evaluation evaluation) -> void
  #
  # @return [FlagProxy] a new instance of FlagProxy
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#49
  def initialize(evaluation); end

  # : (Symbol sym) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#34
  def method_missing(sym); end

  private

  # : (Symbol sym, ?bool include_private) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#44
  def respond_to_missing?(sym, include_private = T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#11
class CLI::Kit::Args::Evaluation::MissingRequiredOption < ::CLI::Kit::Args::Evaluation::Error
  # : (String name) -> void
  #
  # @return [MissingRequiredOption] a new instance of MissingRequiredOption
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#13
  def initialize(name); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#18
class CLI::Kit::Args::Evaluation::MissingRequiredPosition < ::CLI::Kit::Args::Evaluation::Error
  # : -> void
  #
  # @return [MissingRequiredPosition] a new instance of MissingRequiredPosition
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#20
  def initialize; end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#54
class CLI::Kit::Args::Evaluation::OptionProxy
  # : (Evaluation evaluation) -> void
  #
  # @return [OptionProxy] a new instance of OptionProxy
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#71
  def initialize(evaluation); end

  # : (Symbol sym) -> (String | Array[String])?
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#56
  def method_missing(sym); end

  private

  # : (Symbol sym, ?bool include_private) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#66
  def respond_to_missing?(sym, include_private = T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#76
class CLI::Kit::Args::Evaluation::PositionProxy
  # : (Evaluation evaluation) -> void
  #
  # @return [PositionProxy] a new instance of PositionProxy
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#93
  def initialize(evaluation); end

  # : (Symbol sym) -> (String | Array[String])?
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#78
  def method_missing(sym); end

  private

  # : (Symbol sym, ?bool include_private) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#88
  def respond_to_missing?(sym, include_private = T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/args/evaluation.rb#25
class CLI::Kit::Args::Evaluation::TooManyPositions < ::CLI::Kit::Args::Evaluation::Error
  # : -> void
  #
  # @return [TooManyPositions] a new instance of TooManyPositions
  #
  # source://cli-kit//lib/cli/kit/args/evaluation.rb#27
  def initialize; end
end

# source://cli-kit//lib/cli/kit/args/parser.rb#8
class CLI::Kit::Args::Parser
  # : (Definition definition) -> void
  #
  # @return [Parser] a new instance of Parser
  #
  # source://cli-kit//lib/cli/kit/args/parser.rb#63
  def initialize(definition); end

  # : (Array[Tokenizer::Token] tokens) -> Array[Node]
  #
  # source://cli-kit//lib/cli/kit/args/parser.rb#28
  def parse(tokens); end

  private

  # : (Tokenizer::Token::OptionName arg, Tokenizer::Token? next_arg) -> Node
  #
  # source://cli-kit//lib/cli/kit/args/parser.rb#104
  def parse_option(arg, next_arg); end

  # : (Tokenizer::Token token, Tokenizer::Token? next_token) -> [Symbol, Parser::Node]
  #
  # source://cli-kit//lib/cli/kit/args/parser.rb#70
  def parse_token(token, next_token); end
end

# source://cli-kit//lib/cli/kit/args/parser.rb#11
class CLI::Kit::Args::Parser::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/parser.rb#13
class CLI::Kit::Args::Parser::InvalidOptionError < ::CLI::Kit::Args::Parser::Error
  # : (String option) -> void
  #
  # @return [InvalidOptionError] a new instance of InvalidOptionError
  #
  # source://cli-kit//lib/cli/kit/args/parser.rb#15
  def initialize(option); end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#9
class CLI::Kit::Args::Parser::Node
  # : -> void
  #
  # @return [Node] a new instance of Node
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#11
  def initialize; end

  # : (untyped other) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#15
  def ==(other); end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#83
class CLI::Kit::Args::Parser::Node::Argument < ::CLI::Kit::Args::Parser::Node
  # : (String value) -> void
  #
  # @return [Argument] a new instance of Argument
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#88
  def initialize(value); end

  # : (untyped other) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#99
  def ==(other); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#94
  def inspect; end

  # : String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#85
  def value; end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#53
class CLI::Kit::Args::Parser::Node::Flag < ::CLI::Kit::Args::Parser::Node
  # : (String value) -> void
  #
  # @return [Flag] a new instance of Flag
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#58
  def initialize(value); end

  # : (untyped other) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#70
  def ==(other); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#65
  def inspect; end

  # : String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#55
  def value; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#75
class CLI::Kit::Args::Parser::Node::LongFlag < ::CLI::Kit::Args::Parser::Node::Flag
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#45
class CLI::Kit::Args::Parser::Node::LongOption < ::CLI::Kit::Args::Parser::Node::Option
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#19
class CLI::Kit::Args::Parser::Node::Option < ::CLI::Kit::Args::Parser::Node
  # : (String name, String value) -> void
  #
  # @return [Option] a new instance of Option
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#27
  def initialize(name, value); end

  # : (untyped other) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#40
  def ==(other); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#35
  def inspect; end

  # : String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#21
  def name; end

  # : String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#24
  def value; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#79
class CLI::Kit::Args::Parser::Node::ShortFlag < ::CLI::Kit::Args::Parser::Node::Flag
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#49
class CLI::Kit::Args::Parser::Node::ShortOption < ::CLI::Kit::Args::Parser::Node::Option
  class << self
    def new(*_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/args/parser/node.rb#104
class CLI::Kit::Args::Parser::Node::Unparsed < ::CLI::Kit::Args::Parser::Node
  # : (Array[String] value) -> void
  #
  # @return [Unparsed] a new instance of Unparsed
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#109
  def initialize(value); end

  # : (untyped other) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#120
  def ==(other); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#115
  def inspect; end

  # : Array[String]
  #
  # source://cli-kit//lib/cli/kit/args/parser/node.rb#106
  def value; end
end

# source://cli-kit//lib/cli/kit/args/parser.rb#20
class CLI::Kit::Args::Parser::OptionRequiresAnArgumentError < ::CLI::Kit::Args::Parser::Error
  # : (String option) -> void
  #
  # @return [OptionRequiresAnArgumentError] a new instance of OptionRequiresAnArgumentError
  #
  # source://cli-kit//lib/cli/kit/args/parser.rb#22
  def initialize(option); end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#8
module CLI::Kit::Args::Tokenizer
  class << self
    # : (Array[String] raw_args) -> Array[Token]
    #
    # source://cli-kit//lib/cli/kit/args/tokenizer.rb#56
    def tokenize(raw_args); end

    # : (String arg) -> Array[Token]
    #
    # source://cli-kit//lib/cli/kit/args/tokenizer.rb#96
    def tokenize_short_option(arg); end
  end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#9
class CLI::Kit::Args::Tokenizer::Error < ::CLI::Kit::Args::Error; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#18
class CLI::Kit::Args::Tokenizer::InvalidCharInShortOption < ::CLI::Kit::Args::Tokenizer::Error
  # : (String short_option, String char) -> void
  #
  # @return [InvalidCharInShortOption] a new instance of InvalidCharInShortOption
  #
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#20
  def initialize(short_option, char); end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#11
class CLI::Kit::Args::Tokenizer::InvalidShortOption < ::CLI::Kit::Args::Tokenizer::Error
  # : (String short_option) -> void
  #
  # @return [InvalidShortOption] a new instance of InvalidShortOption
  #
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#13
  def initialize(short_option); end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#25
class CLI::Kit::Args::Tokenizer::Token
  # : (String value) -> void
  #
  # @return [Token] a new instance of Token
  #
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#30
  def initialize(value); end

  # : (untyped other) -> bool
  #
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#40
  def ==(other); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#35
  def inspect; end

  # : String
  #
  # source://cli-kit//lib/cli/kit/args/tokenizer.rb#27
  def value; end
end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#45
class CLI::Kit::Args::Tokenizer::Token::LongOptionName < ::CLI::Kit::Args::Tokenizer::Token::OptionName; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#44
class CLI::Kit::Args::Tokenizer::Token::OptionName < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#48
class CLI::Kit::Args::Tokenizer::Token::OptionValue < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#50
class CLI::Kit::Args::Tokenizer::Token::OptionValueOrPositionalArgument < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#49
class CLI::Kit::Args::Tokenizer::Token::PositionalArgument < ::CLI::Kit::Args::Tokenizer::Token; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#46
class CLI::Kit::Args::Tokenizer::Token::ShortOptionName < ::CLI::Kit::Args::Tokenizer::Token::OptionName; end

# source://cli-kit//lib/cli/kit/args/tokenizer.rb#51
class CLI::Kit::Args::Tokenizer::Token::UnparsedArgument < ::CLI::Kit::Args::Tokenizer::Token; end

# @abstract
#
# source://cli-kit//lib/cli/kit/base_command.rb#8
class CLI::Kit::BaseCommand
  include ::CLI::Kit::CommandHelp
  extend ::CLI::Kit::CommandHelp::ClassMethods

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/base_command.rb#25
  def has_subcommands?; end

  class << self
    # : (Array[String] args, String command_name) -> void
    #
    # source://cli-kit//lib/cli/kit/base_command.rb#19
    def call(args, command_name); end

    # : -> bool
    #
    # @return [Boolean]
    #
    # source://cli-kit//lib/cli/kit/base_command.rb#14
    def defined?; end
  end
end

# bug:true; silent:false
#
# source://cli-kit//lib/cli/kit.rb#81
class CLI::Kit::Bug < ::CLI::Kit::GenericAbort; end

# bug:true; silent:true
#
# source://cli-kit//lib/cli/kit.rb#84
class CLI::Kit::BugSilent < ::CLI::Kit::GenericAbort
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit.rb#86
  def silent?; end
end

# source://cli-kit//lib/cli/kit/command_help.rb#7
module CLI::Kit::CommandHelp
  include ::Kernel

  # : (Array[String] args, String name) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#11
  def call(args, name); end

  # : (untyped op, String name) -> void
  #
  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#44
  def invoke(op, name); end

  # use to implement error handling
  # : (untyped op, String name) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#39
  def invoke_wrapper(op, name); end

  class << self
    # : -> Integer
    #
    # source://cli-kit//lib/cli/kit/command_help.rb#65
    def _max_desc_length; end

    # : -> String
    #
    # source://cli-kit//lib/cli/kit/command_help.rb#56
    def _tool_name; end

    # : Integer
    #
    # source://cli-kit//lib/cli/kit/command_help.rb#53
    def max_desc_length=(_arg0); end

    # : String
    #
    # source://cli-kit//lib/cli/kit/command_help.rb#50
    def tool_name=(_arg0); end
  end
end

# source://cli-kit//lib/cli/kit/command_help.rb#70
module CLI::Kit::CommandHelp::ClassMethods
  include ::Kernel

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#103
  def _command_name; end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#111
  def _desc; end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#116
  def build_desc; end

  # : -> String?
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#237
  def build_examples; end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#82
  def build_help; end

  # : -> String?
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#133
  def build_options; end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#223
  def build_usage; end

  # : (String command_name) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#185
  def command_name(command_name); end

  # : (String desc) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#194
  def desc(desc); end

  # : (String command, String? explanation) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#261
  def example(command, explanation); end

  # : (Array[Symbol] sections) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#180
  def help_sections(sections); end

  # : (String long_desc) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#214
  def long_desc(long_desc); end

  # : -> untyped
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#125
  def opts_class; end

  # : (String usage) -> void
  #
  # source://cli-kit//lib/cli/kit/command_help.rb#255
  def usage(usage); end
end

# source://cli-kit//lib/cli/kit/command_help.rb#73
CLI::Kit::CommandHelp::ClassMethods::DEFAULT_HELP_SECTIONS = T.let(T.unsafe(nil), Array)

# source://cli-kit//lib/cli/kit/command_registry.rb#7
class CLI::Kit::CommandRegistry
  # : (default: String, ?contextual_resolver: ContextualResolver) -> void
  #
  # @return [CommandRegistry] a new instance of CommandRegistry
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#62
  def initialize(default:, contextual_resolver: T.unsafe(nil)); end

  # : (command_or_proc const, String name) -> void
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#77
  def add(const, name); end

  # : (String from, String to) -> void
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#90
  def add_alias(from, to); end

  # : Hash[String, String]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#14
  def aliases; end

  # : -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#95
  def command_names; end

  # : Hash[String, command_or_proc]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#11
  def commands; end

  # : (String name) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#100
  def exist?(name); end

  # : (String? name) -> [singleton(CLI::Kit::BaseCommand)?, String]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#82
  def lookup_command(name); end

  # : -> Hash[String, singleton(CLI::Kit::BaseCommand)]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#70
  def resolved_commands; end

  private

  # : (String name) -> String
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#107
  def resolve_alias(name); end

  # : (command_or_proc? class_or_proc) -> singleton(CLI::Kit::BaseCommand)?
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#138
  def resolve_class(class_or_proc); end

  # : (String name) -> [singleton(CLI::Kit::BaseCommand)?, String]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#112
  def resolve_command(name); end

  # : (String name) -> [singleton(CLI::Kit::BaseCommand), String]?
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#130
  def resolve_contextual_command(name); end

  # : (String name) -> [singleton(CLI::Kit::BaseCommand), String]?
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#120
  def resolve_global_command(name); end
end

# source://cli-kit//lib/cli/kit/command_registry.rb#17
module CLI::Kit::CommandRegistry::ContextualResolver
  # : -> Hash[String, String]
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#26
  def aliases; end

  # : (String) -> singleton(CLI::Kit::BaseCommand)
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#32
  def command_class(_name); end

  # : -> Array[String]
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/command_registry.rb#20
  def command_names; end
end

# source://cli-kit//lib/cli/kit/command_registry.rb#37
module CLI::Kit::CommandRegistry::NullContextualResolver
  extend ::CLI::Kit::CommandRegistry::ContextualResolver

  class << self
    # : -> Hash[String, String]
    #
    # source://cli-kit//lib/cli/kit/command_registry.rb#49
    def aliases; end

    # : (String _name) -> singleton(CLI::Kit::BaseCommand)
    #
    # @raise [CLI::Kit::Abort]
    #
    # source://cli-kit//lib/cli/kit/command_registry.rb#55
    def command_class(_name); end

    # : -> Array[String]
    #
    # source://cli-kit//lib/cli/kit/command_registry.rb#43
    def command_names; end
  end
end

# source://cli-kit//lib/cli/kit/config.rb#8
class CLI::Kit::Config
  # : (tool_name: String) -> void
  #
  # @return [Config] a new instance of Config
  #
  # source://cli-kit//lib/cli/kit/config.rb#12
  def initialize(tool_name:); end

  # The path on disk at which the configuration is stored:
  #   `$XDG_CONFIG_HOME/<toolname>/config`
  # if ENV['XDG_CONFIG_HOME'] is not set, we default to ~/.config, e.g.:
  #   ~/.config/tool/config
  #
  # : -> String
  #
  # source://cli-kit//lib/cli/kit/config.rb#110
  def file; end

  # Returns the config corresponding to `name` from the config file
  # `false` is returned if it doesn't exist
  #
  # #### Parameters
  # `section` : the section of the config value you are looking for
  # `name` : the name of the config value you are looking for
  #
  # #### Returns
  # `value` : the value of the config variable (nil if none)
  #
  # #### Example Usage
  # `config.get('name.of.config')`
  #
  # : (String section, String name, ?default: String?) -> String?
  #
  # source://cli-kit//lib/cli/kit/config.rb#30
  def get(section, name, default: T.unsafe(nil)); end

  # Coalesce and enforce the value of a config to a boolean
  # : (String section, String name, ?default: bool?) -> bool?
  #
  # source://cli-kit//lib/cli/kit/config.rb#36
  def get_bool(section, name, default: T.unsafe(nil)); end

  # Gets the hash for the entire section
  #
  # #### Parameters
  # `section` : the section of the config you are getting
  #
  # #### Example Usage
  # `config.get_section('section')`
  #
  # : (String section) -> Hash[String, String]
  #
  # source://cli-kit//lib/cli/kit/config.rb#95
  def get_section(section); end

  # Sets the config value in the config file
  #
  # #### Parameters
  # `section` : the section of the config you are setting
  # `name` : the name of the config you are setting
  # `value` : the value of the config you are setting
  #
  # #### Example Usage
  # `config.set('section', 'name.of.config', 'value')`
  #
  # : (String section, String name, (String | bool)? value) -> void
  #
  # source://cli-kit//lib/cli/kit/config.rb#60
  def set(section, name, value); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/config.rb#100
  def to_s; end

  # Unsets a config value in the config file
  #
  # #### Parameters
  # `section` : the section of the config you are deleting
  # `name` : the name of the config you are deleting
  #
  # #### Example Usage
  # `config.unset('section', 'name.of.config')`
  #
  # : (String section, String name) -> void
  #
  # source://cli-kit//lib/cli/kit/config.rb#82
  def unset(section, name); end

  private

  # : -> Hash[String, Hash[String, String]]
  #
  # source://cli-kit//lib/cli/kit/config.rb#118
  def all_configs; end

  # : -> CLI::Kit::Ini
  #
  # source://cli-kit//lib/cli/kit/config.rb#123
  def ini; end

  # : -> void
  #
  # source://cli-kit//lib/cli/kit/config.rb#128
  def write_config; end
end

# source://cli-kit//lib/cli/kit/config.rb#9
CLI::Kit::Config::XDG_CONFIG_HOME = T.let(T.unsafe(nil), String)

# source://cli-kit//lib/cli/kit.rb#26
CLI::Kit::EXIT_BUG = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit.rb#25
CLI::Kit::EXIT_FAILURE_BUT_NOT_BUG = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit.rb#27
CLI::Kit::EXIT_SUCCESS = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit/error_handler.rb#8
class CLI::Kit::ErrorHandler
  # : (?log_file: String?, ?exception_reporter: exception_reporter_or_proc, ?tool_name: String?, ?dev_mode: bool) -> void
  #
  # @return [ErrorHandler] a new instance of ErrorHandler
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#15
  def initialize(log_file: T.unsafe(nil), exception_reporter: T.unsafe(nil), tool_name: T.unsafe(nil), dev_mode: T.unsafe(nil)); end

  # : { -> void } -> Integer
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#44
  def call(&block); end

  # : ^(Exception arg0) -> Integer
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#12
  def override_exception_handler=(_arg0); end

  # : (Exception? error) -> void
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#52
  def report_exception(error); end

  private

  # : (Exception? error) -> Exception?
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#118
  def exception_for_submission(error); end

  # : -> singleton(ExceptionReporter)
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#156
  def exception_reporter; end

  # : (String message) -> void
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#149
  def stderr_puts(message); end

  # Run the program, handling any errors that occur.
  #
  # Errors are printed to stderr unless they're #silent?, and are reported
  # to bugsnag (by setting @at_exit_exeption for our at_exit handler) if
  # they're #bug?
  #
  # Returns an exit status for the program.
  # : { -> void } -> Integer
  #
  # source://cli-kit//lib/cli/kit/error_handler.rb#80
  def triage_all_exceptions(&block); end
end

# @abstract
#
# source://cli-kit//lib/cli/kit/error_handler.rb#23
class CLI::Kit::ErrorHandler::ExceptionReporter
  class << self
    # : (Exception?, ?String?) -> void
    #
    # @abstract
    # @raise [NotImplementedError]
    #
    # source://cli-kit//lib/cli/kit/error_handler.rb#27
    def report(exception, logs = T.unsafe(nil)); end
  end
end

# source://cli-kit//lib/cli/kit/error_handler.rb#33
class CLI::Kit::ErrorHandler::NullExceptionReporter < ::CLI::Kit::ErrorHandler::ExceptionReporter
  class << self
    # : (Exception? _exception, ?String? _logs) -> void
    #
    # source://cli-kit//lib/cli/kit/error_handler.rb#37
    def report(_exception, _logs = T.unsafe(nil)); end
  end
end

# source://cli-kit//lib/cli/kit/error_handler.rb#66
CLI::Kit::ErrorHandler::SIGNALS_THAT_ARENT_BUGS = T.let(T.unsafe(nil), Array)

# source://cli-kit//lib/cli/kit/executor.rb#9
class CLI::Kit::Executor
  # : (log_file: String) -> void
  #
  # @return [Executor] a new instance of Executor
  #
  # source://cli-kit//lib/cli/kit/executor.rb#11
  def initialize(log_file:); end

  # : (singleton(CLI::Kit::BaseCommand) command, String command_name, Array[String] args) -> void
  #
  # source://cli-kit//lib/cli/kit/executor.rb#17
  def call(command, command_name, args); end

  private

  # : (untyped _sig) -> void
  #
  # source://cli-kit//lib/cli/kit/executor.rb#83
  def info_handler(_sig); end

  # : (untyped _sig) -> void
  #
  # source://cli-kit//lib/cli/kit/executor.rb#73
  def quit_handler(_sig); end

  # : [T] (String signal, Method handler) { -> T } -> T
  #
  # source://cli-kit//lib/cli/kit/executor.rb#54
  def twrap(signal, handler, &block); end

  # : [T] { (String id) -> T } -> T
  #
  # source://cli-kit//lib/cli/kit/executor.rb#38
  def with_logging(&block); end

  # : [T] { -> T } -> T
  #
  # source://cli-kit//lib/cli/kit/executor.rb#47
  def with_traps(&block); end
end

# Abort, Bug, AbortSilent, and BugSilent are four ways of immediately bailing
# on command-line execution when an unrecoverable error occurs.
#
# Note that these don't inherit from StandardError, and so are not caught by
# a bare `rescue => e`.
#
# * Abort prints its message in red and exits 1;
# * Bug additionally submits the exception to the exception_reporter passed to
#     `CLI::Kit::ErrorHandler.new`
# * AbortSilent and BugSilent do the same as above, but do not print
#     messages before exiting.
#
# Treat these like panic() in Go:
#   * Don't rescue them. Use a different Exception class if you plan to recover;
#   * Provide a useful message, since it will be presented in brief to the
#       user, and will be useful for debugging.
#   * Avoid using it if it does actually make sense to recover from an error.
#
# Additionally:
#   * Do not subclass these.
#   * Only use AbortSilent or BugSilent if you prefer to print a more
#       contextualized error than Abort or Bug would present to the user.
#   * In general, don't attach a message to AbortSilent or BugSilent.
#   * Never raise GenericAbort directly.
#   * Think carefully about whether Abort or Bug is more appropriate. Is this
#       a bug in the tool? Or is it just user error, transient network
#       failure, etc.?
#   * One case where it's ok to rescue (cli-kit internals or tests aside):
#       1. rescue Abort or Bug
#       2. Print a contextualized error message
#       3. Re-raise AbortSilent or BugSilent respectively.
#
# These aren't the only exceptions that can carry this 'bug' and 'silent'
# metadata, however:
#
# If you raise an exception with `CLI::Kit.raise(..., bug: x, silent: y)`,
# those last two (optional) keyword arguments will attach the metadata to
# whatever exception you raise. This is interpreted later in the
# ErrorHandler to decide how to print output and whether to submit the
# exception to bugsnag.
#
# source://cli-kit//lib/cli/kit.rb#72
class CLI::Kit::GenericAbort < ::Exception; end

# INI is a language similar to JSON or YAML, but simplied
# The spec is here: https://en.wikipedia.org/wiki/INI_file
# This parser includes supports for 2 very basic uses
# - Sections
# - Key Value Pairs (within and outside of the sections)
#
# [global]
# key = val
#
# Nothing else is supported right now
# See the ini_test.rb file for more examples
#
# source://cli-kit//lib/cli/kit/ini.rb#19
class CLI::Kit::Ini
  # : (?String? path, ?config: String?, ?default_section: String) -> void
  #
  # @return [Ini] a new instance of Ini
  #
  # source://cli-kit//lib/cli/kit/ini.rb#24
  def initialize(path = T.unsafe(nil), config: T.unsafe(nil), default_section: T.unsafe(nil)); end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/ini.rb#53
  def git_format; end

  # : Hash[String, Hash[String, String]]
  #
  # source://cli-kit//lib/cli/kit/ini.rb#21
  def ini; end

  # : Hash[String, Hash[String, String]]
  #
  # source://cli-kit//lib/cli/kit/ini.rb#21
  def ini=(_arg0); end

  # : -> Hash[String, Hash[String, String]]
  #
  # source://cli-kit//lib/cli/kit/ini.rb#35
  def parse; end

  # : -> String
  #
  # source://cli-kit//lib/cli/kit/ini.rb#58
  def to_s; end

  private

  # : (String k) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/ini.rb#86
  def section_designator?(k); end

  # : (String key, String val) -> void
  #
  # source://cli-kit//lib/cli/kit/ini.rb#79
  def set_val(key, val); end

  # : (?git_format: bool) -> String
  #
  # source://cli-kit//lib/cli/kit/ini.rb#65
  def to_ini(git_format: T.unsafe(nil)); end
end

# source://cli-kit//lib/cli/kit/levenshtein.rb#30
module CLI::Kit::Levenshtein
  private

  # source://cli-kit//lib/cli/kit/levenshtein.rb#38
  def distance(str1, str2); end

  # detects the minimum value out of three arguments. This method is
  # faster than `[a, b, c].min` and puts less GC pressure.
  # See https://github.com/yuki24/did_you_mean/pull/1 for a performance
  # benchmark.
  # : (Integer a, Integer b, Integer c) -> Integer
  #
  # source://cli-kit//lib/cli/kit/levenshtein.rb#80
  def min3(a, b, c); end

  class << self
    # source://cli-kit//lib/cli/kit/levenshtein.rb#38
    def distance(str1, str2); end

    # detects the minimum value out of three arguments. This method is
    # faster than `[a, b, c].min` and puts less GC pressure.
    # See https://github.com/yuki24/did_you_mean/pull/1 for a performance
    # benchmark.
    # : (Integer a, Integer b, Integer c) -> Integer
    #
    # source://cli-kit//lib/cli/kit/levenshtein.rb#80
    def min3(a, b, c); end
  end
end

# source://cli-kit//lib/cli/kit/logger.rb#9
class CLI::Kit::Logger
  # Constructor for CLI::Kit::Logger
  #
  # : (debug_log_file: String, ?env_debug_name: String) -> void
  #
  # @param debug_log_file [String] path to the file where debug logs should be stored
  # @return [Logger] a new instance of Logger
  #
  # source://cli-kit//lib/cli/kit/logger.rb#17
  def initialize(debug_log_file:, env_debug_name: T.unsafe(nil)); end

  # Similar to Logger#debug, however will not output to STDOUT unless DEBUG env var is set
  # Logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # : (String msg) -> void
  #
  # @param msg [String] the message to log
  #
  # source://cli-kit//lib/cli/kit/logger.rb#72
  def debug(msg); end

  # Functionally equivalent to Logger#error
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # : (String msg, ?debug: bool) -> void
  #
  # @param msg [String] the message to log
  # @param debug [Boolean] determines if the debug logger will receive the log (default true)
  #
  # source://cli-kit//lib/cli/kit/logger.rb#51
  def error(msg, debug: T.unsafe(nil)); end

  # Functionally equivalent to Logger#fatal
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # : (String msg, ?debug: bool) -> void
  #
  # @param msg [String] the message to log
  # @param debug [Boolean] determines if the debug logger will receive the log (default true)
  #
  # source://cli-kit//lib/cli/kit/logger.rb#62
  def fatal(msg, debug: T.unsafe(nil)); end

  # Functionally equivalent to Logger#info
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # : (String msg, ?debug: bool) -> void
  #
  # @param msg [String] the message to log
  # @param debug [Boolean] determines if the debug logger will receive the log (default true)
  #
  # source://cli-kit//lib/cli/kit/logger.rb#29
  def info(msg, debug: T.unsafe(nil)); end

  # Functionally equivalent to Logger#warn
  # Also logs to the debug file, taking into account CLI::UI::StdoutRouter.current_id
  #
  # : (String msg, ?debug: bool) -> void
  #
  # @param msg [String] the message to log
  # @param debug [Boolean] determines if the debug logger will receive the log (default true)
  #
  # source://cli-kit//lib/cli/kit/logger.rb#40
  def warn(msg, debug: T.unsafe(nil)); end

  private

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/logger.rb#88
  def debug?; end

  # : (String msg) -> String
  #
  # source://cli-kit//lib/cli/kit/logger.rb#80
  def format_debug(msg); end
end

# 5MB
#
# source://cli-kit//lib/cli/kit/logger.rb#10
CLI::Kit::Logger::MAX_LOG_SIZE = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit/logger.rb#11
CLI::Kit::Logger::MAX_NUM_LOGS = T.let(T.unsafe(nil), Integer)

# source://cli-kit//lib/cli/kit/opts.rb#7
class CLI::Kit::Opts
  include ::CLI::Kit::Opts::Mixin
  extend ::CLI::Kit::Opts::Mixin::MixinClassMethods

  # : (String name) -> (String | bool)?
  #
  # source://cli-kit//lib/cli/kit/opts.rb#196
  def [](name); end

  # : -> Args::Evaluation
  #
  # @raise [NotImplementedError]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#223
  def assert_result!; end

  # : (Args::Definition defn) -> void
  #
  # source://cli-kit//lib/cli/kit/opts.rb#230
  def define!(defn); end

  # : ?{ (Symbol arg0, bool arg1) -> void } -> untyped
  #
  # source://cli-kit//lib/cli/kit/opts.rb#184
  def each_flag(&block); end

  # : ?{ (Symbol arg0, String? arg1) -> void } -> untyped
  #
  # source://cli-kit//lib/cli/kit/opts.rb#172
  def each_option(&block); end

  # : (Args::Evaluation ev) -> void
  #
  # source://cli-kit//lib/cli/kit/opts.rb#242
  def evaluate!(ev); end

  # : -> bool
  #
  # source://cli-kit//lib/cli/kit/opts.rb#161
  def helpflag; end

  # : (String name) -> bool
  #
  # source://cli-kit//lib/cli/kit/opts.rb#215
  def lookup_flag(name); end

  # : (String name) -> String?
  #
  # source://cli-kit//lib/cli/kit/opts.rb#206
  def lookup_option(name); end

  # : -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#166
  def unparsed; end
end

# source://cli-kit//lib/cli/kit/opts.rb#158
CLI::Kit::Opts::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Array)

# source://cli-kit//lib/cli/kit/opts.rb#8
module CLI::Kit::Opts::Mixin
  include ::Kernel

  mixes_in_class_methods ::CLI::Kit::Opts::Mixin::MixinClassMethods

  # : (?name: Symbol, ?short: String?, ?long: String?, ?desc: String?) -> bool
  #
  # source://cli-kit//lib/cli/kit/opts.rb#89
  def flag(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil)); end

  # : (?name: Symbol, ?short: String?, ?long: String?, ?desc: String?, ?default: (Array[String] | ^-> Array[String])) -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#76
  def multi_option(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil)); end

  # : (?name: Symbol, ?short: String?, ?long: String?, ?desc: String?, ?default: (String | ^-> String)?) -> String?
  #
  # source://cli-kit//lib/cli/kit/opts.rb#46
  def option(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil)); end

  # : (?name: Symbol, ?short: String?, ?long: String?, ?desc: String?, ?default: (String | ^-> String)?) -> String
  #
  # source://cli-kit//lib/cli/kit/opts.rb#63
  def option!(name: T.unsafe(nil), short: T.unsafe(nil), long: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil)); end

  # : (?name: Symbol, ?desc: String?, ?default: (String | ^-> String)?, ?skip: (^-> bool | ^(String arg0) -> bool)?) -> String?
  #
  # source://cli-kit//lib/cli/kit/opts.rb#111
  def position(name: T.unsafe(nil), desc: T.unsafe(nil), default: T.unsafe(nil), skip: T.unsafe(nil)); end

  # : (?name: Symbol, ?desc: String?) -> String
  #
  # source://cli-kit//lib/cli/kit/opts.rb#100
  def position!(name: T.unsafe(nil), desc: T.unsafe(nil)); end

  # : (?name: Symbol, ?desc: String?) -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#122
  def rest(name: T.unsafe(nil), desc: T.unsafe(nil)); end

  private

  # : -> Symbol
  #
  # @raise [ArgumentError]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#142
  def infer_name; end

  # : (String? label) -> Symbol?
  #
  # source://cli-kit//lib/cli/kit/opts.rb#135
  def symbolize(label); end

  class << self
    # : (Module klass) -> void
    #
    # source://cli-kit//lib/cli/kit/opts.rb#40
    def included(klass); end
  end
end

# source://cli-kit//lib/cli/kit/opts.rb#11
module CLI::Kit::Opts::Mixin::MixinClassMethods
  # : (Module included_module) -> void
  #
  # source://cli-kit//lib/cli/kit/opts.rb#13
  def include(included_module); end

  # No signature - Sorbet uses method_added internally, so can't verify it
  #
  # source://cli-kit//lib/cli/kit/opts.rb#21
  def method_added(method_name); end

  # : (Symbol method_name) -> void
  #
  # source://cli-kit//lib/cli/kit/opts.rb#27
  def track_method(method_name); end

  # : -> Array[Symbol]
  #
  # source://cli-kit//lib/cli/kit/opts.rb#33
  def tracked_methods; end
end

# source://cli-kit//lib/cli/kit/parse_args.rb#5
module CLI::Kit::ParseArgs
  include ::Kernel

  # : ((Array | String) args, Hash[Symbol, Array[untyped]] opts_defn) -> Hash[Symbol, untyped]
  #
  # source://cli-kit//lib/cli/kit/parse_args.rb#15
  def parse_args(args, opts_defn); end
end

# source://cli-kit//lib/cli/kit/resolver.rb#7
class CLI::Kit::Resolver
  # : (tool_name: String, command_registry: CLI::Kit::CommandRegistry) -> void
  #
  # @return [Resolver] a new instance of Resolver
  #
  # source://cli-kit//lib/cli/kit/resolver.rb#9
  def initialize(tool_name:, command_registry:); end

  # : (Array[String] args) -> [singleton(CLI::Kit::BaseCommand), String, Array[String]]
  #
  # source://cli-kit//lib/cli/kit/resolver.rb#15
  def call(args); end

  private

  # : (String? name) -> void
  #
  # source://cli-kit//lib/cli/kit/resolver.rb#32
  def command_not_found(name); end

  # : -> Array[String]
  #
  # source://cli-kit//lib/cli/kit/resolver.rb#61
  def commands_and_aliases; end
end

# source://cli-kit//lib/cli/kit/support.rb#7
module CLI::Kit::Support; end

# source://cli-kit//lib/cli/kit/support/test_helper.rb#6
module CLI::Kit::Support::TestHelper
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#12
  def assert_all_commands_run(should_raise: T.unsafe(nil)); end

  # source://cli-kit//lib/cli/kit/support/test_helper.rb#7
  def setup; end

  # source://cli-kit//lib/cli/kit/support/test_helper.rb#22
  def teardown; end
end

# source://cli-kit//lib/cli/kit/support/test_helper.rb#29
module CLI::Kit::Support::TestHelper::FakeConfig
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#33
  def setup; end

  # source://cli-kit//lib/cli/kit/support/test_helper.rb#40
  def teardown; end
end

# source://cli-kit//lib/cli/kit/support/test_helper.rb#47
class CLI::Kit::Support::TestHelper::FakeSuccess
  # @return [FakeSuccess] a new instance of FakeSuccess
  #
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#48
  def initialize(success); end

  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/support/test_helper.rb#52
  def success?; end
end

# source://cli-kit//lib/cli/kit/system.rb#9
module CLI::Kit::System
  class << self
    # Execute a command in the user's environment
    # This is meant to be largely equivalent to backticks, only with the env passed in.
    # Captures the results of the command without output to the console
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional arguments to pass to Open3.capture2
    #
    # #### Returns
    # - `output`: output (STDOUT) of the command execution
    # - `status`: boolean success status of the command execution
    #
    # #### Usage
    # `out, stat = CLI::Kit::System.capture2('ls', 'a_folder')`
    #
    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], **untyped kwargs) -> [String, Process::Status]
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#79
    def capture2(cmd, *a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # Execute a command in the user's environment
    # This is meant to be largely equivalent to backticks, only with the env passed in.
    # Captures the results of the command without output to the console
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional arguments to pass to Open3.capture2e
    #
    # #### Returns
    # - `output`: output (STDOUT merged with STDERR) of the command execution
    # - `status`: boolean success status of the command execution
    #
    # #### Usage
    # `out_and_err, stat = CLI::Kit::System.capture2e('ls', 'a_folder')`
    #
    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], **untyped kwargs) -> [String, Process::Status]
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#99
    def capture2e(cmd, *a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # Execute a command in the user's environment
    # This is meant to be largely equivalent to backticks, only with the env passed in.
    # Captures the results of the command without output to the console
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional arguments to pass to Open3.capture3
    #
    # #### Returns
    # - `output`: STDOUT of the command execution
    # - `error`: STDERR of the command execution
    # - `status`: boolean success status of the command execution
    #
    # #### Usage
    # `out, err, stat = CLI::Kit::System.capture3('ls', 'a_folder')`
    #
    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], **untyped kwargs) -> [String, String, Process::Status]
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#119
    def capture3(cmd, *a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # Returns the errors associated to a test run
    #
    # #### Returns
    # `errors` (String) a string representing errors found on this run, nil if none
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#183
    def error_message; end

    # Sets up an expectation for a command and stubs out the call (unless allow is true)
    #
    # #### Parameters
    # `*a` : the command, represented as a splat
    # `stdout` : stdout to stub the command with (defaults to empty string)
    # `stderr` : stderr to stub the command with (defaults to empty string)
    # `allow` : allow determines if the command will be actually run, or stubbed. Defaults to nil (stub)
    # `success` : success status to stub the command with (Defaults to nil)
    # `sudo` : expectation of sudo being set or not (defaults to false)
    # `env` : expectation of env being set or not (defaults to {})
    #
    # Note: Must set allow or success
    #
    # @raise [ArgumentError]
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#152
    def fake(*a, stdout: T.unsafe(nil), stderr: T.unsafe(nil), allow: T.unsafe(nil), success: T.unsafe(nil), sudo: T.unsafe(nil), env: T.unsafe(nil)); end

    # source://cli-kit//lib/cli/kit/system.rb#50
    def original_capture2(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # source://cli-kit//lib/cli/kit/system.rb#72
    def original_capture2e(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # source://cli-kit//lib/cli/kit/system.rb#95
    def original_capture3(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

    # source://cli-kit//lib/cli/kit/system.rb#130
    def original_system(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), stdin: T.unsafe(nil), **kwargs, &block); end

    # : -> Symbol
    #
    # source://cli-kit//lib/cli/kit/system.rb#226
    def os; end

    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], **untyped kwargs) ?{ (IO stdin, IO stdout, Process::Waiter wait_thr) -> [IO, IO, Process::Waiter] } -> [IO, IO, Process::Waiter]
    #
    # source://cli-kit//lib/cli/kit/system.rb#100
    def popen2(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], **untyped kwargs) ?{ (IO stdin, IO stdout, Process::Waiter wait_thr) -> [IO, IO, Process::Waiter] } -> [IO, IO, Process::Waiter]
    #
    # source://cli-kit//lib/cli/kit/system.rb#105
    def popen2e(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], **untyped kwargs) ?{ (IO stdin, IO stdout, IO stderr, Process::Waiter wait_thr) -> [IO, IO, IO, Process::Waiter] } -> [IO, IO, IO, Process::Waiter]
    #
    # source://cli-kit//lib/cli/kit/system.rb#110
    def popen3(cmd, *args, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

    # Resets the faked commands
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#175
    def reset!; end

    # Split off trailing partial UTF-8 Characters. UTF-8 Multibyte characters start with a 11xxxxxx byte that tells
    # how many following bytes are part of this character, followed by some number of 10xxxxxx bytes.  This simple
    # algorithm will split off a whole trailing multi-byte character.
    # : (String data) -> [String, String]
    #
    # source://cli-kit//lib/cli/kit/system.rb#186
    def split_partial_characters(data); end

    # Ask for sudo access with a message explaning the need for it
    # Will make subsequent commands capable of running with sudo for a period of time
    #
    # #### Parameters
    # - `msg`: A message telling the user why sudo is needed
    #
    # #### Usage
    # `ctx.sudo_reason("We need to do a thing")`
    #
    # : (String msg) -> void
    #
    # source://cli-kit//lib/cli/kit/system.rb#22
    def sudo_reason(msg); end

    # Execute a command in the user's environment
    # Outputs result of the command without capturing it
    #
    # #### Parameters
    # - `*a`: A splat of arguments evaluated as a command. (e.g. `'rm', folder` is equivalent to `rm #{folder}`)
    # - `sudo`: If truthy, run this command with sudo. If String, pass to `sudo_reason`
    # - `env`: process environment with which to execute this command
    # - `**kwargs`: additional keyword arguments to pass to Process.spawn
    #
    # #### Returns
    # - `status`: The `Process:Status` result for the command execution
    #
    # #### Usage
    # `stat = CLI::Kit::System.system('ls', 'a_folder')`
    #
    # : (String cmd, *String args, ?sudo: (String | bool), ?env: Hash[String, String?], ?stdin: (IO | String | Integer | Symbol)?, **untyped kwargs) ?{ (String out, String err) -> void } -> Process::Status
    #
    # source://cli-kit//lib/cli/kit/support/test_helper.rb#62
    def system(cmd, *a, sudo: T.unsafe(nil), env: T.unsafe(nil), stdin: T.unsafe(nil), **kwargs); end

    # : (String cmd, Hash[String, String?] env) -> String?
    #
    # source://cli-kit//lib/cli/kit/system.rb#235
    def which(cmd, env); end

    private

    # : (String cmd, Array[String] args, (String | bool) sudo) -> [String, Array[String]]
    #
    # source://cli-kit//lib/cli/kit/system.rb#250
    def apply_sudo(cmd, args, sudo); end

    # : (String cmd, Array[String] args, Hash[Symbol, untyped] kwargs, ?sudo: (String | bool), ?env: Hash[String, String?], ?method: Symbol) ?{ (?) -> untyped } -> untyped
    #
    # source://cli-kit//lib/cli/kit/system.rb#258
    def delegate_open3(cmd, args, kwargs, sudo: T.unsafe(nil), env: T.unsafe(nil), method: T.unsafe(nil), &block); end

    # source://cli-kit//lib/cli/kit/support/test_helper.rb#240
    def expected_command(a, sudo: T.unsafe(nil), env: T.unsafe(nil)); end

    # Ruby resolves the program to execute using its own PATH, but we want it to
    # use the provided one, so we ensure ruby chooses to spawn a shell, which will
    # parse our command and properly spawn our target using the provided environment.
    #
    # This is important because dev clobbers its own environment such that ruby
    # means /usr/bin/ruby, but we want it to select the ruby targeted by the active
    # project.
    #
    # See https://github.com/Shopify/dev/pull/625 for more details.
    # : (String cmd, Array[String] args, Hash[String, String?] env) -> [String, Array[String]]
    #
    # source://cli-kit//lib/cli/kit/system.rb#277
    def resolve_path(cmd, args, env); end
  end
end

# source://cli-kit//lib/cli/kit/system.rb#10
CLI::Kit::System::SUDO_PROMPT = T.let(T.unsafe(nil), String)

# : untyped
#
# source://cli-kit//lib/cli/kit.rb#29
CLI::Kit::UNTYPED_NIL = T.let(T.unsafe(nil), T.untyped)

# source://cli-kit//lib/cli/kit/util.rb#7
module CLI::Kit::Util
  class << self
    # Must call retry_after on the result in order to execute the block
    #
    # Example usage:
    #
    # CLI::Kit::Util.begin do
    #   might_raise_if_costly_prep_not_done()
    # end.retry_after(ExpectedError) do
    #   costly_prep()
    # end
    # : [T] { -> T } -> Retrier[T]
    #
    # source://cli-kit//lib/cli/kit/util.rb#82
    def begin(&block_that_might_raise); end

    # Converts an integer representing bytes into a human readable format
    #
    # : (Integer bytes, ?precision: Integer, ?space: bool) -> String
    #
    # source://cli-kit//lib/cli/kit/util.rb#13
    def to_filesize(bytes, precision: T.unsafe(nil), space: T.unsafe(nil)); end

    # Converts a number to a human readable format on the SI scale
    #
    # : (Numeric number, ?String unit, ?factor: Integer, ?precision: Integer, ?space: bool) -> String
    #
    # @raise [ArgumentError]
    #
    # source://cli-kit//lib/cli/kit/util.rb#20
    def to_si_scale(number, unit = T.unsafe(nil), factor: T.unsafe(nil), precision: T.unsafe(nil), space: T.unsafe(nil)); end

    # Dir.chdir, when invoked in block form, complains when we call chdir
    # again recursively. There's no apparent good reason for this, so we
    # simply implement our own block form of Dir.chdir here.
    # : [T] (String dir) { -> T } -> T
    #
    # source://cli-kit//lib/cli/kit/util.rb#62
    def with_dir(dir, &block); end
  end
end

# : [BlockReturnType]
#
# source://cli-kit//lib/cli/kit/util.rb#88
class CLI::Kit::Util::Retrier
  # : (^-> BlockReturnType block_that_might_raise) -> void
  #
  # @return [Retrier] a new instance of Retrier
  #
  # source://cli-kit//lib/cli/kit/util.rb#90
  def initialize(block_that_might_raise); end

  # : (?singleton(Exception) exception, ?retries: Integer) ?{ (Exception e) -> void } -> BlockReturnType
  #
  # source://cli-kit//lib/cli/kit/util.rb#95
  def retry_after(exception = T.unsafe(nil), retries: T.unsafe(nil), &before_retry); end
end

# source://cli-kit//lib/cli/kit/core_ext.rb#4
class Exception
  # : (?bool bug) -> void
  #
  # source://cli-kit//lib/cli/kit/core_ext.rb#20
  def bug!(bug = T.unsafe(nil)); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/core_ext.rb#10
  def bug?; end

  # : (?bool silent) -> void
  #
  # source://cli-kit//lib/cli/kit/core_ext.rb#25
  def silent!(silent = T.unsafe(nil)); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-kit//lib/cli/kit/core_ext.rb#15
  def silent?; end
end

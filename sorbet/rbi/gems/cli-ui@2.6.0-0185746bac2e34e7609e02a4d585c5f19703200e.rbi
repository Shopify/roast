# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-ui` gem.
# Please instead update this file by running `bin/tapioca gem cli-ui`.


# source://cli-ui//lib/cli/ui.rb#4
module CLI; end

# source://cli-ui//lib/cli/ui.rb#5
module CLI::UI
  class << self
    # Convenience Method for +CLI::UI::Prompt.any_key+
    #
    # ==== Attributes
    #
    # * +prompt+ - prompt to present
    #
    # : (?String prompt) -> String?
    #
    # source://cli-ui//lib/cli/ui.rb#94
    def any_key(prompt = T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Prompt.ask+
    # : (String question, ?options: Array[String]?, ?default: (String | Array[String])?, ?is_file: bool, ?allow_empty: bool, ?multiple: bool, ?filter_ui: bool, ?select_ui: bool) ?{ (Prompt::OptionsHandler handler) -> void } -> (String | Array[String])
    #
    # source://cli-ui//lib/cli/ui.rb#100
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

    # Convenience Method for +CLI::UI::Prompt.confirm+
    #
    # ==== Attributes
    #
    # * +question+ - question to confirm
    #
    # : (String question, ?default: bool) -> bool
    #
    # source://cli-ui//lib/cli/ui.rb#83
    def confirm(question, default: T.unsafe(nil)); end

    # Turn colour in Formatter, Frame, and Spinner output on or off.
    #
    # ==== Attributes
    #
    # * +bool+ - true or false; enable or disable colour.
    #
    # : (bool bool) -> void
    #
    # source://cli-ui//lib/cli/ui.rb#303
    def enable_color=(bool); end

    # Check whether colour is enabled in Formatter, Frame, and Spinner output.
    # By default, colour is enabled when STDOUT is a TTY; that is, when output
    # has not been directed to another program or to a file.
    #
    # : -> bool
    #
    # @return [Boolean]
    #
    # source://cli-ui//lib/cli/ui.rb#292
    def enable_color?; end

    # Turn cursor control in Formatter, Frame, and Spinner output on or off.
    #
    # ==== Attributes
    #
    # * +bool+ - true or false; enable or disable cursor control.
    #
    # : (bool bool) -> void
    #
    # source://cli-ui//lib/cli/ui.rb#323
    def enable_cursor=(bool); end

    # Check whether cursor control is enabled in Formatter, Frame, and Spinner output.
    # By default, cursor control is enabled when STDOUT is a TTY; that is, when output
    # has not been directed to another program or to a file.
    #
    # : -> bool
    #
    # @return [Boolean]
    #
    # source://cli-ui//lib/cli/ui.rb#312
    def enable_cursor?; end

    # Convenience Method to format text using +CLI::UI::Formatter.format+
    # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options
    #
    # https://user-images.githubusercontent.com/3074765/33799827-6d0721a2-dd01-11e7-9ab5-c3d455264afe.png
    # https://user-images.githubusercontent.com/3074765/33799847-9ec03fd0-dd01-11e7-93f7-5f5cc540e61e.png
    #
    # ==== Attributes
    #
    # * +input+ - input to format
    #
    # ==== Options
    #
    # * +enable_color+ - should color be used? default to true unless output is redirected.
    #
    # : (String input, ?enable_color: bool) -> String
    #
    # source://cli-ui//lib/cli/ui.rb#156
    def fmt(input, enable_color: T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Frame.open+
    #
    # ==== Attributes
    #
    # * +args+ - arguments for +Frame.open+
    # * +block+ - block for +Frame.open+
    #
    # : [T] (String text, ?color: colorable?, ?failure_text: String?, ?success_text: String?, ?timing: (Numeric | bool), ?frame_style: frame_stylable, ?to: io_like) ?{ -> T } -> T?
    #
    # source://cli-ui//lib/cli/ui.rb#201
    def frame(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil), &block); end

    # Set the default frame style.
    # Convenience method for setting the default frame style with +CLI::UI::Frame.frame_style=+
    #
    # Raises ArgumentError if +frame_style+ is not valid
    #
    # ==== Attributes
    #
    # * +symbol+ - the default frame style to use for frames
    #
    # : (frame_stylable frame_style) -> void
    #
    # source://cli-ui//lib/cli/ui.rb#337
    def frame_style=(frame_style); end

    # Glyph resolution using +CLI::UI::Glyph.lookup+
    # Look at the method signature for +Glyph.lookup+ for more details
    #
    # ==== Attributes
    #
    # * +handle+ - handle of the glyph to resolve
    #
    # : (String handle) -> Glyph
    #
    # source://cli-ui//lib/cli/ui.rb#39
    def glyph(handle); end

    # Create a terminal link
    # : (String url, String text, ?format: bool, ?blue_underline: bool) -> String
    #
    # source://cli-ui//lib/cli/ui.rb#343
    def link(url, text, format: T.unsafe(nil), blue_underline: T.unsafe(nil)); end

    # Duplicate output to a file path
    #
    # ==== Attributes
    #
    # * +path+ - path to duplicate output to
    #
    # : [T] (String path) { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui.rb#254
    def log_output_to(path, &block); end

    # Convenience Method for +CLI::UI::Printer.puts+
    #
    # ==== Attributes
    #
    # * +msg+ - Message to print
    # * +kwargs+ - keyword arguments for +Printer.puts+
    #
    #
    # source://cli-ui//lib/cli/ui.rb#173
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end

    # Disable all framing within a block
    #
    # ==== Attributes
    #
    # * +block+ - block in which to disable frames
    #
    # : [T] { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui.rb#279
    def raw(&block); end

    # Color resolution using +CLI::UI::Color.lookup+
    # Will lookup using +Color.lookup+ unless it's already a CLI::UI::Color (or nil)
    #
    # ==== Attributes
    #
    # * +input+ - color to resolve
    #
    # : (colorable input) -> CLI::UI::Color
    #
    # source://cli-ui//lib/cli/ui.rb#51
    def resolve_color(input); end

    # Frame style resolution using +CLI::UI::Frame::FrameStyle.lookup+.
    # Will lookup using +FrameStyle.lookup+ unless it's already a CLI::UI::Frame::FrameStyle(or nil)
    #
    # ==== Attributes
    #
    # * +input+ - frame style to resolve
    # : (frame_stylable input) -> CLI::UI::Frame::FrameStyle
    #
    # source://cli-ui//lib/cli/ui.rb#67
    def resolve_style(input); end

    # Convenience Method to resolve text using +CLI::UI::Formatter.format+
    # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options
    #
    # ==== Attributes
    #
    # * +input+ - input to format
    # * +truncate_to+ - number of characters to truncate the string to (or nil)
    # * +enable_color+ - should color be used? default to true unless output is redirected.
    #
    # : (String input, ?truncate_to: Integer?, ?enable_color: bool) -> String
    #
    # source://cli-ui//lib/cli/ui.rb#134
    def resolve_text(input, truncate_to: T.unsafe(nil), enable_color: T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Spinner.spin+
    #
    # ==== Attributes
    #
    # * +args+ - arguments for +Spinner.open+
    # * +block+ - block for +Spinner.open+
    #
    # : (String title, ?auto_debrief: bool, ?to: io_like) { (Spinner::SpinGroup::Task task) -> void } -> bool
    #
    # source://cli-ui//lib/cli/ui.rb#231
    def spinner(title, auto_debrief: T.unsafe(nil), to: T.unsafe(nil), &block); end

    # Convenience Method to override frame color using +CLI::UI::Frame.with_frame_color+
    #
    # ==== Attributes
    #
    # * +color+ - color to override to
    # * +block+ - block for +Frame.with_frame_color_override+
    #
    # : [T] (colorable color) { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui.rb#243
    def with_frame_color(color, &block); end

    # : (String input) -> String
    #
    # source://cli-ui//lib/cli/ui.rb#161
    def wrap(input); end
  end
end

# source://cli-ui//lib/cli/ui/ansi.rb#6
module CLI::UI::ANSI
  class << self
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#200
    def clear_to_end_of_line; end

    # Returns an ANSI control sequence
    #
    # ==== Attributes
    #
    # - +args+ - Argument to pass to the ANSI control sequence
    # - +cmd+ - ANSI control sequence Command
    #
    # : (String args, String cmd) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#54
    def control(args, cmd); end

    # Move the cursor back n columns
    #
    # ==== Attributes
    #
    # * +n+ - number of columns by which to move the cursor back
    #
    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#112
    def cursor_back(n = T.unsafe(nil)); end

    # Move the cursor down n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor down
    #
    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#86
    def cursor_down(n = T.unsafe(nil)); end

    # Move the cursor forward n columns
    #
    # ==== Attributes
    #
    # * +n+ - number of columns by which to move the cursor forward
    #
    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#99
    def cursor_forward(n = T.unsafe(nil)); end

    # Move the cursor to a specific column
    #
    # ==== Attributes
    #
    # * +n+ - The column to move to
    #
    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#125
    def cursor_horizontal_absolute(n = T.unsafe(nil)); end

    # Restore the saved cursor position
    #
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#170
    def cursor_restore; end

    # Save the cursor position
    #
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#163
    def cursor_save; end

    # Move the cursor up n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor up
    #
    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#73
    def cursor_up(n = T.unsafe(nil)); end

    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#132
    def enter_alternate_screen; end

    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#137
    def exit_alternate_screen; end

    # Hide the cursor
    #
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#156
    def hide_cursor; end

    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#205
    def insert_line; end

    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#210
    def insert_lines(n = T.unsafe(nil)); end

    # : -> Regexp
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#142
    def match_alternate_screen; end

    # Move to the next line
    #
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#177
    def next_line; end

    # Move to the previous line
    #
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#184
    def previous_line; end

    # Move to the previous n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor up
    #
    # : (?Integer n) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#195
    def previous_lines(n = T.unsafe(nil)); end

    # ANSI escape sequences (like \x1b[31m) have zero width.
    # when calculating the padding width, we must exclude them.
    # This also implements a basic version of utf8 character width calculation like
    # we could get for real from something like utf8proc.
    #
    # : (String str) -> Integer
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#16
    def printing_width(str); end

    # https://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    # : (String params) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#60
    def sgr(params); end

    # Show the cursor
    #
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#149
    def show_cursor; end

    # Strips ANSI codes from a str
    #
    # ==== Attributes
    #
    # - +str+ - The string from which to strip codes
    #
    # : (String str) -> String
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#42
    def strip_codes(str); end
  end
end

# source://cli-ui//lib/cli/ui/ansi.rb#7
CLI::UI::ANSI::ESC = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/color.rb#6
class CLI::UI::Color
  # Creates a new color mapping
  # Signatures can be found here:
  # https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
  #
  # ==== Attributes
  #
  # * +sgr+ - The color signature
  # * +name+ - The name of the color
  #
  # : (String sgr, Symbol name) -> void
  #
  # @return [Color] a new instance of Color
  #
  # source://cli-ui//lib/cli/ui/color.rb#23
  def initialize(sgr, name); end

  # : String
  #
  # source://cli-ui//lib/cli/ui/color.rb#8
  def code; end

  # : Symbol
  #
  # source://cli-ui//lib/cli/ui/color.rb#11
  def name; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/color.rb#8
  def sgr; end

  class << self
    # All available colors by name
    #
    # : -> Array[Symbol]
    #
    # source://cli-ui//lib/cli/ui/color.rb#93
    def available; end

    # Looks up a color code by name
    #
    # ==== Raises
    # Raises a InvalidColorName if the color is not available
    # You likely need to add it to the +MAP+ or you made a typo
    #
    # ==== Returns
    # Returns a color code
    #
    # : ((Symbol | String) name) -> Color
    #
    # source://cli-ui//lib/cli/ui/color.rb#84
    def lookup(name); end
  end
end

# default blue is low-contrast against black in some default terminal color scheme
#
# source://cli-ui//lib/cli/ui/color.rb#33
CLI::UI::Color::BLUE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#37
CLI::UI::Color::BOLD = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#35
CLI::UI::Color::CYAN = T.let(T.unsafe(nil), CLI::UI::Color)

# 240 is very dark gray; 255 is very light gray. 244 is somewhat dark.
#
# source://cli-ui//lib/cli/ui/color.rb#41
CLI::UI::Color::GRAY = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#30
CLI::UI::Color::GREEN = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#58
class CLI::UI::Color::InvalidColorName < ::ArgumentError
  # : (Symbol name) -> void
  #
  # @return [InvalidColorName] a new instance of InvalidColorName
  #
  # source://cli-ui//lib/cli/ui/color.rb#60
  def initialize(name); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/color.rb#66
  def message; end
end

# source://cli-ui//lib/cli/ui/color.rb#34
CLI::UI::Color::MAGENTA = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#45
CLI::UI::Color::MAP = T.let(T.unsafe(nil), Hash)

# Using color 214 from the 256-color palette for a more distinct orange
#
# source://cli-ui//lib/cli/ui/color.rb#43
CLI::UI::Color::ORANGE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#29
CLI::UI::Color::RED = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#36
CLI::UI::Color::RESET = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#38
CLI::UI::Color::WHITE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#31
CLI::UI::Color::YELLOW = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/formatter.rb#9
class CLI::UI::Formatter
  # Initialize a formatter with text.
  #
  # ===== Attributes
  #
  # * +text+ - the text to format
  #
  # : (String text) -> void
  #
  # @return [Formatter] a new instance of Formatter
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#84
  def initialize(text); end

  # Format the text using a map.
  #
  # ===== Attributes
  #
  # * +sgr_map+ - the mapping of the formattings. Defaults to +SGR_MAP+
  #
  # ===== Options
  #
  # * +:enable_color+ - enable color output? Default is true unless output is redirected
  #
  # : (?Hash[String, String] sgr_map, ?enable_color: bool) -> String
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#100
  def format(sgr_map = T.unsafe(nil), enable_color: T.unsafe(nil)); end

  private

  # : (String text, stack fmt, Hash[String, String] sgr_map) -> String
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#127
  def apply_format(text, fmt, sgr_map); end

  # : (String text, stack stack) -> void
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#212
  def emit(text, stack); end

  # : (StringScanner sc, ?stack stack) -> stack
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#190
  def parse_body(sc, stack = T.unsafe(nil)); end

  # : (StringScanner sc, stack stack) -> stack
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#145
  def parse_expr(sc, stack); end
end

# source://cli-ui//lib/cli/ui/formatter.rb#41
CLI::UI::Formatter::BEGIN_EXPR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/formatter.rb#56
CLI::UI::Formatter::DISCARD_BRACES = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/formatter.rb#42
CLI::UI::Formatter::END_EXPR = T.let(T.unsafe(nil), String)

# : type stack = Array[String | LITERAL_BRACES]
#
# source://cli-ui//lib/cli/ui/formatter.rb#62
class CLI::UI::Formatter::FormatError < ::StandardError
  # : (String message, String input, Integer index) -> void
  #
  # @return [FormatError] a new instance of FormatError
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#70
  def initialize(message, input, index); end

  # : Integer
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#67
  def index; end

  # : Integer
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#67
  def index=(_arg0); end

  # : String
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#64
  def input; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#64
  def input=(_arg0); end
end

# source://cli-ui//lib/cli/ui/formatter.rb#58
class CLI::UI::Formatter::LITERAL_BRACES; end

# source://cli-ui//lib/cli/ui/formatter.rb#47
CLI::UI::Formatter::SCAN_BODY = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#45
CLI::UI::Formatter::SCAN_FUNCNAME = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#46
CLI::UI::Formatter::SCAN_GLYPH = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#44
CLI::UI::Formatter::SCAN_WIDGET = T.let(T.unsafe(nil), Regexp)

# Available mappings of formattings
# To use any of them, you can use {{<key>:<string>}}
# There are presentational (colours and formatters)
# and semantic (error, info, command) formatters available
#
# source://cli-ui//lib/cli/ui/formatter.rb#15
CLI::UI::Formatter::SGR_MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#6
module CLI::UI::Frame
  class << self
    # Closes a frame
    # Automatically called for a block-form +open+
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to nil
    # * +:elapsed+ - How long did the frame take? Defaults to nil
    # * +frame_style+ - The frame style to use for this frame.  Defaults to nil
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Example
    #
    #   CLI::UI::Frame.close('Close')
    #
    # Default Output:
    #   ┗━━ Close ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # ==== Raises
    #
    # MUST be inside an open frame or it raises a +UnnestedFrameException+
    #
    # : (String? text, ?color: colorable?, ?elapsed: Numeric?, ?frame_style: frame_stylable?, ?to: io_like) -> void
    #
    # @raise [UnnestedFrameException]
    #
    # source://cli-ui//lib/cli/ui/frame.rb#202
    def close(text, color: T.unsafe(nil), elapsed: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil)); end

    # Adds a divider in a frame
    # Used to separate information within a single frame
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+
    # * +frame_style+ - The frame style to use for this frame
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Example
    #
    #   CLI::UI::Frame.open('Open') { CLI::UI::Frame.divider('Divider') }
    #
    # Default Output:
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #   ┣━━ Divider ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # ==== Raises
    #
    # MUST be inside an open frame or it raises a +UnnestedFrameException+
    #
    # : (String? text, ?color: colorable?, ?frame_style: frame_stylable?, ?to: io_like) -> void
    #
    # @raise [UnnestedFrameException]
    #
    # source://cli-ui//lib/cli/ui/frame.rb#160
    def divider(text, color: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil)); end

    # : -> FrameStyle
    #
    # source://cli-ui//lib/cli/ui/frame.rb#15
    def frame_style; end

    # Set the default frame style.
    #
    # Raises ArgumentError if +frame_style+ is not valid
    #
    # ==== Attributes
    #
    # * +symbol+ or +FrameStyle+ - the default frame style to use for frames
    #
    # : (frame_stylable frame_style) -> void
    #
    # source://cli-ui//lib/cli/ui/frame.rb#28
    def frame_style=(frame_style); end

    # Opens a new frame. Can be nested
    # Can be invoked in two ways: block and blockless
    # * In block form, the frame is closed automatically when the block returns
    # * In blockless form, caller MUST call +Frame.close+ when the frame is logically done
    # * Blockless form is strongly discouraged in cases where block form can be made to work
    #
    # https://user-images.githubusercontent.com/3074765/33799861-cb5dcb5c-dd01-11e7-977e-6fad38cee08c.png
    #
    # The return value of the block determines if the block is a "success" or a "failure"
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+
    # * +:failure_text+ - If the block failed, what do we output? Defaults to nil
    # * +:success_text+ - If the block succeeds, what do we output? Defaults to nil
    # * +:timing+ - How long did the frame content take? Invalid for blockless. Defaults to true for the block form
    # * +frame_style+ - The frame style to use for this frame
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Example
    #
    # ===== Block Form (Assumes +CLI::UI::StdoutRouter.enable+ has been called)
    #
    #   CLI::UI::Frame.open('Open') { puts 'hi' }
    #
    # Default Output:
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #   ┃ hi
    #   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ (0.0s) ━━
    #
    # ===== Blockless Form
    #
    #   CLI::UI::Frame.open('Open')
    #
    # Default Output:
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    #
    # : [T] (String text, ?color: colorable, ?failure_text: String?, ?success_text: String?, ?timing: (Numeric | bool), ?frame_style: frame_stylable, ?to: io_like) ?{ -> T } -> T?
    #
    # source://cli-ui//lib/cli/ui/frame.rb#76
    def open(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil), &block); end

    # Determines the prefix of a frame entry taking multi-nested frames into account
    #
    # ==== Options
    #
    # * +:color+ - The color of the prefix. Defaults to +Thread.current[:cliui_frame_color_override]+
    #
    # : (?color: colorable?) -> String
    #
    # source://cli-ui//lib/cli/ui/frame.rb#223
    def prefix(color: T.unsafe(nil)); end

    # The width of a prefix given the number of Frames in the stack
    # : -> Integer
    #
    # source://cli-ui//lib/cli/ui/frame.rb#245
    def prefix_width; end

    # Override a color for a given thread.
    #
    # ==== Attributes
    #
    # * +color+ - The color to override to
    #
    # : [T] (colorable color) { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/frame.rb#260
    def with_frame_color_override(color, &block); end

    private

    # If timing is:
    #   Numeric: return it
    #   false: return nil
    #   true: defaults to Time.new
    # : (Time start, (Numeric | bool) timing) -> Numeric?
    #
    # source://cli-ui//lib/cli/ui/frame.rb#275
    def elapsed(start, timing); end
  end
end

# source://cli-ui//lib/cli/ui/frame.rb#11
CLI::UI::Frame::DEFAULT_FRAME_COLOR = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#7
module CLI::UI::Frame::FrameStack
  class << self
    # Fetch all items off the frame stack
    # : -> Array[StackItem]
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#25
    def items; end

    # Removes and returns the last stack item off the stack
    # : -> StackItem?
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#60
    def pop; end

    # Push a new item onto the frame stack.
    #
    # Either an item or a :color/:style pair should be pushed onto the stack.
    #
    # ==== Attributes
    #
    # * +item+ a +StackItem+ to push onto the stack. Defaults to nil
    #
    # ==== Options
    #
    # * +:color+ the color of the new stack item. Defaults to nil
    # * +:style+ the style of the new stack item. Defaults to nil
    #
    # ==== Raises
    #
    # If both an item and a color/style pair are given, raises an +ArgumentError+
    # If the given item is not a +StackItem+, raises an +ArgumentError+
    #
    # : (?StackItem? item, ?color: CLI::UI::Color?, ?style: CLI::UI::Frame::FrameStyle?) -> void
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#48
    def push(item = T.unsafe(nil), color: T.unsafe(nil), style: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#8
class CLI::UI::Frame::FrameStack::StackItem
  # : (CLI::UI::colorable color_name, frame_stylable style_name) -> void
  #
  # @return [StackItem] a new instance of StackItem
  #
  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#16
  def initialize(color_name, style_name); end

  # : CLI::UI::Color
  #
  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#10
  def color; end

  # : CLI::UI::Frame::FrameStyle
  #
  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#13
  def frame_style; end
end

# @abstract
#
# source://cli-ui//lib/cli/ui/frame/frame_style.rb#10
module CLI::UI::Frame::FrameStyle
  include ::Kernel

  # Draws the "Close" line for this frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  # * +:right_text+ - Text to print at the right of the line. Defaults to nil
  #
  # : (String, color: CLI::UI::Color, ?right_text: String?) -> String
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#84
  def close(text, color:, right_text: T.unsafe(nil)); end

  # Draws a "divider" line for the current frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  #
  # : (String, color: CLI::UI::Color) -> String
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#100
  def divider(text, color:); end

  # Returns the character(s) that should be printed at the beginning
  # of lines inside this frame
  # : -> String
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#45
  def prefix; end

  # Returns the printing width of the prefix
  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#51
  def prefix_width; end

  # : (Integer x, String str) -> String
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#105
  def print_at_x(x, str); end

  # Draws the "Open" line for this frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  #
  # : (String, color: CLI::UI::Color) -> String
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#67
  def start(text, color:); end

  # : -> Symbol
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#37
  def style_name; end

  class << self
    # Lookup a frame style via its name
    #
    # ==== Attributes
    #
    # * +symbol+ - frame style name to lookup
    # : ((String | Symbol) name) -> FrameStyle
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style.rb#28
    def lookup(name); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#8
module CLI::UI::Frame::FrameStyle::Box
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    # Draws the "Close" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    # * +:right_text+ - Text to print at the right of the line. Defaults to nil
    #
    # ==== Output:
    #
    #   ┗━━ Close ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # : (String text, color: CLI::UI::Color, ?right_text: String?) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#87
    def close(text, color:, right_text: T.unsafe(nil)); end

    # Draws a "divider" line for the current frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   ┣━━ Divider ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # : (String text, color: CLI::UI::Color) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#66
    def divider(text, color:); end

    # : -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#26
    def prefix; end

    # Draws the "Open" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   ┏━━ Open ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    #
    # : (String text, color: CLI::UI::Color) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#46
    def start(text, color:); end

    # : -> Symbol
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#20
    def style_name; end

    private

    # : (String text, color: CLI::UI::Color, first: String, ?right_text: String?) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#94
    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#15
CLI::UI::Frame::FrameStyle::Box::BOTTOM_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#13
CLI::UI::Frame::FrameStyle::Box::DIVIDER = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#12
CLI::UI::Frame::FrameStyle::Box::HORIZONTAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#14
CLI::UI::Frame::FrameStyle::Box::TOP_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#11
CLI::UI::Frame::FrameStyle::Box::VERTICAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#8
module CLI::UI::Frame::FrameStyle::Bracket
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    # Draws the "Close" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    # * +:right_text+ - Text to print at the right of the line. Defaults to nil
    #
    # ==== Output:
    #
    #   ┗━━ Close
    #
    # : (String text, color: CLI::UI::Color, ?right_text: String?) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#87
    def close(text, color:, right_text: T.unsafe(nil)); end

    # Draws a "divider" line for the current frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   ┣━━ Divider
    #
    # : (String text, color: CLI::UI::Color) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#66
    def divider(text, color:); end

    # : -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#26
    def prefix; end

    # Draws the "Open" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output
    #
    #   ┏━━ Open
    #
    # : (String text, color: CLI::UI::Color) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#46
    def start(text, color:); end

    # : -> Symbol
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#20
    def style_name; end

    private

    # : (String text, color: CLI::UI::Color, first: String, ?right_text: String?) -> String
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#94
    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#15
CLI::UI::Frame::FrameStyle::Bracket::BOTTOM_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#13
CLI::UI::Frame::FrameStyle::Bracket::DIVIDER = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#12
CLI::UI::Frame::FrameStyle::Bracket::HORIZONTAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#14
CLI::UI::Frame::FrameStyle::Bracket::TOP_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#11
CLI::UI::Frame::FrameStyle::Bracket::VERTICAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style.rb#109
class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName < ::ArgumentError
  # : ((String | Symbol) name) -> void
  #
  # @return [InvalidFrameStyleName] a new instance of InvalidFrameStyleName
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#111
  def initialize(name); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#117
  def message; end
end

# source://cli-ui//lib/cli/ui/frame/frame_style.rb#16
CLI::UI::Frame::FrameStyle::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/frame.rb#10
class CLI::UI::Frame::UnnestedFrameException < ::StandardError; end

# source://cli-ui//lib/cli/ui/glyph.rb#6
class CLI::UI::Glyph
  # Creates a new glyph
  #
  # ==== Attributes
  #
  # * +handle+ - The handle in the +MAP+ constant
  # * +codepoint+ - The codepoint used to create the glyph (e.g. +0x2717+ for a ballot X)
  # * +plain+ - A fallback plain string to be used in case glyphs are disabled
  # * +color+ - What color to output the glyph. Check +CLI::UI::Color+ for options.
  #
  # : (String handle, (Integer | Array[Integer]) codepoint, String plain, Color color) -> void
  #
  # @return [Glyph] a new instance of Glyph
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#41
  def initialize(handle, codepoint, plain, color); end

  # : String
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#23
  def char; end

  # : (Integer | Array[Integer])
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#26
  def codepoint; end

  # : Color
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#29
  def color; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#23
  def fmt; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#23
  def handle; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#23
  def to_s; end

  class << self
    # All available glyphs by name
    #
    # : -> Array[String]
    #
    # source://cli-ui//lib/cli/ui/glyph.rb#84
    def available; end

    # Looks up a glyph by name
    #
    # ==== Raises
    # Raises a InvalidGlyphHandle if the glyph is not available
    # You likely need to create it with +.new+ or you made a typo
    #
    # ==== Returns
    # Returns a terminal output-capable string
    #
    # : (String name) -> Glyph
    #
    # source://cli-ui//lib/cli/ui/glyph.rb#75
    def lookup(name); end
  end
end

# Bug emoji (🐛)
#
# source://cli-ui//lib/cli/ui/glyph.rb#59
CLI::UI::Glyph::BUG = T.let(T.unsafe(nil), CLI::UI::Glyph)

# GREEN CHECK MARK (✓)
#
# source://cli-ui//lib/cli/ui/glyph.rb#57
CLI::UI::Glyph::CHECK = T.let(T.unsafe(nil), CLI::UI::Glyph)

# RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (»)
#
# source://cli-ui//lib/cli/ui/glyph.rb#60
CLI::UI::Glyph::CHEVRON = T.let(T.unsafe(nil), CLI::UI::Glyph)

# HOURGLASS (⧖)
#
# source://cli-ui//lib/cli/ui/glyph.rb#61
CLI::UI::Glyph::HOURGLASS = T.let(T.unsafe(nil), CLI::UI::Glyph)

# BLUE MATHEMATICAL SCRIPT SMALL i (𝒾)
#
# source://cli-ui//lib/cli/ui/glyph.rb#55
CLI::UI::Glyph::INFO = T.let(T.unsafe(nil), CLI::UI::Glyph)

# source://cli-ui//lib/cli/ui/glyph.rb#7
class CLI::UI::Glyph::InvalidGlyphHandle < ::ArgumentError
  # : (String handle) -> void
  #
  # @return [InvalidGlyphHandle] a new instance of InvalidGlyphHandle
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#9
  def initialize(handle); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#15
  def message; end
end

# Mapping of glyphs to terminal output
#
# source://cli-ui//lib/cli/ui/glyph.rb#53
CLI::UI::Glyph::MAP = T.let(T.unsafe(nil), Hash)

# BLUE QUESTION MARK (?)
#
# source://cli-ui//lib/cli/ui/glyph.rb#56
CLI::UI::Glyph::QUESTION = T.let(T.unsafe(nil), CLI::UI::Glyph)

# YELLOW SMALL STAR (⭑)
#
# source://cli-ui//lib/cli/ui/glyph.rb#54
CLI::UI::Glyph::STAR = T.let(T.unsafe(nil), CLI::UI::Glyph)

# WARNING SIGN + VARIATION SELECTOR 16 (⚠️ )
#
# source://cli-ui//lib/cli/ui/glyph.rb#62
CLI::UI::Glyph::WARNING = T.let(T.unsafe(nil), CLI::UI::Glyph)

# RED BALLOT X (✗)
#
# source://cli-ui//lib/cli/ui/glyph.rb#58
CLI::UI::Glyph::X = T.let(T.unsafe(nil), CLI::UI::Glyph)

# source://cli-ui//lib/cli/ui/os.rb#8
class CLI::UI::OS
  # : (?emoji: bool, ?color_prompt: bool, ?arrow_keys: bool, ?shift_cursor: bool) -> void
  #
  # @return [OS] a new instance of OS
  #
  # source://cli-ui//lib/cli/ui/os.rb#10
  def initialize(emoji: T.unsafe(nil), color_prompt: T.unsafe(nil), arrow_keys: T.unsafe(nil), shift_cursor: T.unsafe(nil)); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/os.rb#33
  def shift_cursor_back_on_horizontal_absolute?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/os.rb#28
  def suggest_arrow_keys?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/os.rb#23
  def use_color_prompt?; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/os.rb#18
  def use_emoji?; end

  class << self
    # : -> OS
    #
    # source://cli-ui//lib/cli/ui/os.rb#39
    def current; end
  end
end

# source://cli-ui//lib/cli/ui/os.rb#59
CLI::UI::OS::FREEBSD = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#58
CLI::UI::OS::LINUX = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#57
CLI::UI::OS::MAC = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#60
CLI::UI::OS::WINDOWS = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/printer.rb#6
class CLI::UI::Printer
  class << self
    # Print a message to a stream with common utilities.
    # Allows overriding the color, encoding, and target stream.
    # By default, it formats the string using CLI:UI and rescues common stream errors.
    #
    # ==== Attributes
    #
    # * +msg+ - (required) the string to output. Can be frozen.
    #
    # ==== Options
    #
    # * +:frame_color+ - Override the frame color. Defaults to nil.
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with a puts method. Defaults to $stdout.
    # * +:encoding+ - Force the output to be in a certain encoding. Defaults to UTF-8.
    # * +:format+ - Whether to format the string using CLI::UI.fmt. Defaults to true.
    # * +:graceful+ - Whether to gracefully ignore common I/O errors. Defaults to true.
    # * +:wrap+ - Whether to wrap text at word boundaries to terminal width. Defaults to true.
    #
    # ==== Returns
    # Returns whether the message was successfully printed,
    # which can be useful if +:graceful+ is set to true.
    #
    # ==== Example
    #
    #   CLI::UI::Printer.puts('{{x}} Ouch', to: $stderr)
    #
    #
    # source://cli-ui//lib/cli/ui/printer.rb#34
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/progress.rb#6
class CLI::UI::Progress
  # Initialize a progress bar. Typically used in a +Progress.progress+ block
  #
  # ==== Options
  #
  # * +:title+ - The title of the progress bar
  # * +:width+ - The width of the terminal
  # * +:reporter+ - The progress reporter instance
  #
  # : (?String? title, ?width: Integer, ?reporter: ProgressReporter::Reporter?) -> void
  #
  # @return [Progress] a new instance of Progress
  #
  # source://cli-ui//lib/cli/ui/progress.rb#65
  def initialize(title = T.unsafe(nil), width: T.unsafe(nil), reporter: T.unsafe(nil)); end

  # Set the progress of the bar. Typically used in a +Progress.progress+ block
  #
  # ==== Options
  # One of the follow can be used, but not both together
  #
  # * +:percent+ - Increment progress by a specific percent amount
  # * +:set_percent+ - Set progress to a specific percent
  #
  # *Note:* The +:percent+ and +:set_percent must be between 0.00 and 1.0
  #
  # : (?percent: Numeric?, ?set_percent: Numeric?) -> void
  #
  # @raise [ArgumentError]
  #
  # source://cli-ui//lib/cli/ui/progress.rb#83
  def tick(percent: T.unsafe(nil), set_percent: T.unsafe(nil)); end

  # Format the progress bar to be printed to terminal
  #
  # : -> String
  #
  # source://cli-ui//lib/cli/ui/progress.rb#113
  def to_s; end

  # Update the progress bar title
  #
  # ==== Attributes
  #
  # * +new_title+ - title to change the progress bar to
  #
  # : (String new_title) -> void
  #
  # source://cli-ui//lib/cli/ui/progress.rb#106
  def update_title(new_title); end

  class << self
    # Add a progress bar to the terminal output
    #
    # https://user-images.githubusercontent.com/3074765/33799794-cc4c940e-dd00-11e7-9bdc-90f77ec9167c.gif
    #
    # ==== Example Usage:
    #
    # Set the percent to X
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick(set_percent: percent)
    #   end
    #
    # Increase the percent by 1 percent
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick
    #   end
    #
    # Increase the percent by X
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick(percent: 0.05)
    #   end
    #
    # Update the title
    #   CLI::UI::Progress.progress('Title') do |bar|
    #     bar.tick(percent: 0.05)
    #     bar.update_title('New title')
    #   end
    # : [T] (?String? title, ?width: Integer) { (Progress bar) -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/progress.rb#40
    def progress(title = T.unsafe(nil), width: T.unsafe(nil), &block); end
  end
end

# A Cyan filled block
#
# source://cli-ui//lib/cli/ui/progress.rb#8
CLI::UI::Progress::FILLED_BAR = T.let(T.unsafe(nil), String)

# A bright white block
#
# source://cli-ui//lib/cli/ui/progress.rb#10
CLI::UI::Progress::UNFILLED_BAR = T.let(T.unsafe(nil), String)

# Handles terminal progress bar reporting using ConEmu OSC 9;4 sequences
# Supports:
# - Numerical progress (0-100%)
# - Indeterminate/pulsing progress
# - Success/error states
# - Paused state
#
# source://cli-ui//lib/cli/ui/progress_reporter.rb#12
module CLI::UI::ProgressReporter
  class << self
    # : -> Reporter?
    #
    # source://cli-ui//lib/cli/ui/progress_reporter.rb#165
    def current_reporter; end

    # Thread-local storage for the current reporter stack
    # : -> Array[Reporter]
    #
    # source://cli-ui//lib/cli/ui/progress_reporter.rb#160
    def reporter_stack; end

    # : -> bool
    #
    # @return [Boolean]
    #
    # source://cli-ui//lib/cli/ui/progress_reporter.rb#183
    def supports_progress?; end

    # Block-based API that ensures progress is cleared
    # : [T] (?mode: Symbol, ?to: io_like, ?delay_start: bool) { (Reporter reporter) -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/progress_reporter.rb#171
    def with_progress(mode: T.unsafe(nil), to: T.unsafe(nil), delay_start: T.unsafe(nil), &block); end
  end
end

# Progress reporter instance that manages the lifecycle of progress reporting
#
# source://cli-ui//lib/cli/ui/progress_reporter.rb#14
class CLI::UI::ProgressReporter::Reporter
  # : (Symbol mode, ?io_like to, ?parent: Reporter?, ?delay_start: bool) -> void
  #
  # @return [Reporter] a new instance of Reporter
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#27
  def initialize(mode, to = T.unsafe(nil), parent: T.unsafe(nil), delay_start: T.unsafe(nil)); end

  # : (Reporter child) -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#51
  def add_child(child); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#137
  def cleanup; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#128
  def clear; end

  # Force indeterminate mode even if there are children
  # : -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#99
  def force_set_indeterminate; end

  # Force progress mode even if there are children - used by SpinGroup
  # when a task needs to show deterministic progress
  # : (Integer percentage) -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#89
  def force_set_progress(percentage); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#61
  def has_active_children?; end

  # : (Reporter child) -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#56
  def remove_child(child); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#107
  def set_error; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#77
  def set_indeterminate; end

  # : (?Integer? percentage) -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#115
  def set_paused(percentage = T.unsafe(nil)); end

  # : (Integer percentage) -> void
  #
  # source://cli-ui//lib/cli/ui/progress_reporter.rb#66
  def set_progress(percentage); end
end

# source://cli-ui//lib/cli/ui/progress_reporter.rb#22
CLI::UI::ProgressReporter::Reporter::ERROR = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/progress_reporter.rb#23
CLI::UI::ProgressReporter::Reporter::INDETERMINATE = T.let(T.unsafe(nil), Integer)

# OSC (Operating System Command) escape sequences
#
# source://cli-ui//lib/cli/ui/progress_reporter.rb#16
CLI::UI::ProgressReporter::Reporter::OSC = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/progress_reporter.rb#24
CLI::UI::ProgressReporter::Reporter::PAUSED = T.let(T.unsafe(nil), Integer)

# Progress states
#
# source://cli-ui//lib/cli/ui/progress_reporter.rb#20
CLI::UI::ProgressReporter::Reporter::REMOVE = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/progress_reporter.rb#21
CLI::UI::ProgressReporter::Reporter::SET_PROGRESS = T.let(T.unsafe(nil), Integer)

# String Terminator (BEL)
#
# source://cli-ui//lib/cli/ui/progress_reporter.rb#17
CLI::UI::ProgressReporter::Reporter::ST = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt.rb#14
module CLI::UI::Prompt
  class << self
    # Present the user with a message and wait for any key to be pressed, returning the pressed key.
    #
    # ==== Example Usage:
    #
    #   CLI::UI::Prompt.any_key # Press any key to continue...
    #
    #   CLI::UI::Prompt.any_key('Press RETURN to continue...') # Then check if that's what they pressed
    # : (?String prompt) -> String?
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#202
    def any_key(prompt = T.unsafe(nil)); end

    # Ask a user a question with either free form answer or a set of answers (multiple choice)
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control multiple choice selection
    # Do not use this method for yes/no questions. Use +confirm+
    #
    # * Handles free form answers (options are nil)
    # * Handles default answers for free form text
    # * Handles file auto completion for file input
    # * Handles interactively choosing answers using +InteractiveOptions+
    #
    # https://user-images.githubusercontent.com/3074765/33799822-47f23302-dd01-11e7-82f3-9072a5a5f611.png
    #
    # ==== Attributes
    #
    # * +question+ - (required) The question to ask the user
    #
    # ==== Options
    #
    # * +:options+ - Options that the user may select from. Will use +InteractiveOptions+ to do so.
    # * +:default+ - The default answer to the question (e.g. they just press enter and don't input anything)
    # * +:is_file+ - Tells the input to use file auto-completion (tab completion)
    # * +:allow_empty+ - Allows the answer to be empty
    # * +:multiple+ - Allow multiple options to be selected
    # * +:filter_ui+ - Enable option filtering (default: true)
    # * +:select_ui+ - Enable long-form option selection (default: true)
    #
    # Note:
    # * +:options+ or providing a +Block+ conflicts with +:default+ and +:is_file+,
    #              you cannot set options with either of these keywords
    # * +:default+ conflicts with +:allow_empty:, you cannot set these together
    # * +:options+ conflicts with providing a +Block+ , you may only set one
    # * +:multiple+ can only be used with +:options+ or a +Block+; it is ignored, otherwise.
    #
    # ==== Block (optional)
    #
    # * A Proc that provides a +OptionsHandler+ and uses the public +:option+ method to add options and their
    #   respective handlers
    #
    # ==== Return Value
    #
    # * If a +Block+ was not provided, the selected option or response to the free form question will be returned
    # * If a +Block+ was provided, the evaluated value of the +Block+ will be returned
    #
    # ==== Example Usage:
    #
    # Free form question
    #   CLI::UI::Prompt.ask('What color is the sky?')
    #
    # Free form question with a file answer
    #   CLI::UI::Prompt.ask('Where is your Gemfile located?', is_file: true)
    #
    # Free form question with a default answer
    #   CLI::UI::Prompt.ask('What color is the sky?', default: 'blue')
    #
    # Free form question when the answer can be empty
    #   CLI::UI::Prompt.ask('What is your opinion on this question?', allow_empty: true)
    #
    # Interactive (multiple choice) question
    #   CLI::UI::Prompt.ask('What kind of project is this?', options: %w(rails go ruby python))
    #
    # Interactive (multiple choice) question with defined handlers
    #   CLI::UI::Prompt.ask('What kind of project is this?') do |handler|
    #     handler.option('rails')  { |selection| selection }
    #     handler.option('go')     { |selection| selection }
    #     handler.option('ruby')   { |selection| selection }
    #     handler.option('python') { |selection| selection }
    #   end
    #
    # : (String question, ?options: Array[String]?, ?default: (String | Array[String])?, ?is_file: bool, ?allow_empty: bool, ?multiple: bool, ?filter_ui: bool, ?select_ui: bool) ?{ (OptionsHandler handler) -> void } -> (String | Array[String])
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#103
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

    # Asks the user for a single-line answer, without displaying the characters while typing.
    # Typically used for password prompts
    #
    # ==== Return Value
    #
    # The password, without a trailing newline.
    # If the user simply presses "Enter" without typing any password, this will return an empty string.
    # : (String question) -> String
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#159
    def ask_password(question); end

    # Asks the user a yes/no question.
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    #
    # ==== Example Usage:
    #
    # Confirmation question
    #   CLI::UI::Prompt.confirm('Is the sky blue?')
    #
    #   CLI::UI::Prompt.confirm('Do a dangerous thing?', default: false)
    #
    # : (String question, ?default: bool) -> bool
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#190
    def confirm(question, default: T.unsafe(nil)); end

    # : -> Color
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#20
    def instructions_color; end

    # Set the instructions color.
    #
    # ==== Attributes
    #
    # * +color+ - the color to use for prompt instructions
    #
    # : (colorable color) -> void
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#31
    def instructions_color=(color); end

    # Wait for any key to be pressed, returning the pressed key.
    # : -> String?
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#211
    def read_char; end

    private

    # : (String question, String? default, bool is_file, bool allow_empty) -> String
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#227
    def ask_free_form(question, default, is_file, allow_empty); end

    # : (String question, ?Array[String]? options, ?multiple: bool, ?default: (String | Array[String])?, ?filter_ui: bool, ?select_ui: bool) -> (String | Array[String])
    #
    # @raise [ArgumentError]
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#256
    def ask_interactive(question, options = T.unsafe(nil), multiple: T.unsafe(nil), default: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil)); end

    # Useful for stubbing in tests
    # : (Array[String] options, ?multiple: bool, ?default: (Array[String] | String)?) -> (Array[String] | String)
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#315
    def interactive_prompt(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

    # : (String str) -> void
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#335
    def puts_question(str); end

    # : (?is_file: bool) -> String
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#340
    def readline(is_file: T.unsafe(nil)); end

    # : (String default) -> void
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#322
    def write_default_over_empty_input(default); end
  end
end

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#10
class CLI::UI::Prompt::InteractiveOptions
  # Initializes a new +InteractiveOptions+
  # Usually called from +self.call+
  #
  # ==== Example Usage:
  #
  #   CLI::UI::Prompt::InteractiveOptions.new(%w(rails go python))
  #
  # : (Array[String] options, ?multiple: bool, ?default: (String | Array[String])?) -> void
  #
  # @return [InteractiveOptions] a new instance of InteractiveOptions
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#52
  def initialize(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

  # Calls the +InteractiveOptions+ and asks the question
  # Usually used from +self.call+
  #
  # : -> (Integer | Array[Integer])
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#84
  def call; end

  private

  # : (String char) -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#298
  def build_selection(char); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#104
  def calculate_option_line_lengths; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#304
  def chop_selection; end

  # : (?Integer number_of_lines) -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#143
  def clear_output(number_of_lines = T.unsafe(nil)); end

  # Don't use this in place of +@displaying_metadata+, this updates too
  # quickly to be useful when drawing to the screen.
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#159
  def display_metadata?; end

  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#490
  def distance_from_selection_to_end; end

  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#495
  def distance_from_start_to_selection; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#199
  def down; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#510
  def ensure_first_item_is_continuation_marker; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#505
  def ensure_last_item_is_continuation_marker; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#483
  def ensure_visible_is_active; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#410
  def filtering?; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#210
  def first_option; end

  # : (String format, String choice) -> String
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#571
  def format_choice(format, choice); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#415
  def has_filter?; end

  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#500
  def index_of_active_option; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#216
  def last_option; end

  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#515
  def max_lines; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#222
  def next_page; end

  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#164
  def num_lines; end

  # : (?recalculate: bool) -> Array[[String, Integer?]]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#440
  def presented_options(recalculate: T.unsafe(nil)); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#233
  def previous_page; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#336
  def process_input_until_redraw_required; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#520
  def render_options; end

  # : (?Integer number_of_lines) -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#134
  def reset_position(number_of_lines = T.unsafe(nil)); end

  # : (String char) -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#288
  def select_bool(char); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#328
  def select_current; end

  # n is 1-indexed selection
  # n == 0 if "Done" was selected in @multiple mode
  # : (Integer n, ?final: bool) -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#247
  def select_n(n, final: T.unsafe(nil)); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#405
  def selecting?; end

  # : (Integer n) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#274
  def should_enter_select_mode?(n); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#420
  def start_filter; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#426
  def start_line_select; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#433
  def stop_line_select; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#178
  def terminal_width_changed?; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#188
  def up; end

  # : (String char) -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#310
  def update_search(char); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#343
  def wait_for_user_input; end

  class << self
    # Prompts the user with options
    # Uses an interactive session to allow the user to pick an answer
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    # For more than 9 options, hitting 'e', ':', or 'G' will enter select
    # mode allowing the user to type in longer numbers
    # Pressing 'f' or '/' will allow the user to filter the results
    #
    # https://user-images.githubusercontent.com/3074765/33797984-0ebb5e64-dcdf-11e7-9e7e-7204f279cece.gif
    #
    # ==== Example Usage:
    #
    # Ask an interactive question
    #   CLI::UI::Prompt::InteractiveOptions.call(%w(rails go python))
    #
    # : (Array[String] options, ?multiple: bool, ?default: (String | Array[String])?) -> (String | Array[String])
    #
    # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#30
    def call(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#183
CLI::UI::Prompt::InteractiveOptions::BACKSPACE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#12
CLI::UI::Prompt::InteractiveOptions::CHECKBOX_ICON = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#184
CLI::UI::Prompt::InteractiveOptions::CTRL_C = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#185
CLI::UI::Prompt::InteractiveOptions::CTRL_D = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#11
CLI::UI::Prompt::InteractiveOptions::DONE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#182
CLI::UI::Prompt::InteractiveOptions::ESC = T.let(T.unsafe(nil), String)

# A class that handles the various options of an InteractivePrompt and their callbacks
#
# source://cli-ui//lib/cli/ui/prompt/options_handler.rb#8
class CLI::UI::Prompt::OptionsHandler
  # : -> void
  #
  # @return [OptionsHandler] a new instance of OptionsHandler
  #
  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#10
  def initialize; end

  # : ((Array[String] | String) options) -> String
  #
  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#25
  def call(options); end

  # : (String option) { (String option) -> String } -> void
  #
  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#20
  def option(option, &handler); end

  # : -> Array[String]
  #
  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#15
  def options; end
end

class CLI::UI::ReentrantMutex < ::Thread::Mutex
  def initialize; end

  def count; end
  def lock; end
  def synchronize; end
  def unlock; end

  private

  def decrease_count(thread); end
  def delete_count(thread); end
  def increase_count(thread); end
end

# Convenience accessor to +CLI::UI::Spinner::SpinGroup+
#
# source://cli-ui//lib/cli/ui.rb#24
CLI::UI::SpinGroup = CLI::UI::Spinner::SpinGroup

# source://cli-ui//lib/cli/ui/spinner.rb#6
module CLI::UI::Spinner
  class << self
    # We use this from CLI::UI::Widgets::Status to render an additional
    # spinner next to the "working" element. While this global state looks
    # a bit repulsive at first, it's worth realizing that:
    #
    # * It's managed by the SpinGroup#wait method, not individual tasks; and
    # * It would be complete insanity to run two separate but concurrent SpinGroups.
    #
    # While it would be possible to stitch through some connection between
    # the SpinGroup and the Widgets included in its title, this is simpler
    # in practice and seems unlikely to cause issues in practice.
    # : -> String
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#38
    def current_rune; end

    # : Integer?
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#25
    def index; end

    # : Integer?
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#25
    def index=(_arg0); end

    # Adds a single spinner
    # Uses an interactive session to allow the user to pick an answer
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    #
    # https://user-images.githubusercontent.com/3074765/33798295-d94fd822-dce3-11e7-819b-43e5502d490e.gif
    #
    # ==== Attributes
    #
    # * +title+ - Title of the spinner to use
    #
    # ==== Options
    #
    # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Block
    #
    # * *spinner+ - Instance of the spinner. Can call +update_title+ to update the user of changes
    #
    # ==== Example Usage:
    #
    #   CLI::UI::Spinner.spin('Title') { sleep 1.0 }
    #
    # : (String title, ?auto_debrief: bool, ?to: io_like) { (SpinGroup::Task task) -> void } -> bool
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#69
    def spin(title, auto_debrief: T.unsafe(nil), to: T.unsafe(nil), &block); end
  end
end

# source://cli-ui//lib/cli/ui/spinner/async.rb#7
class CLI::UI::Spinner::Async
  # Initializes a new asynchronous spinner with no specific end.
  # Must call +.stop+ to end the spinner
  #
  # ==== Attributes
  #
  # * +title+ - Title of the spinner to use
  #
  # ==== Example Usage:
  #
  #   CLI::UI::Spinner::Async.new('Title')
  #
  # : (String title) -> void
  #
  # @return [Async] a new instance of Async
  #
  # source://cli-ui//lib/cli/ui/spinner/async.rb#29
  def initialize(title); end

  # Stops an asynchronous spinner
  #
  # : -> bool
  #
  # source://cli-ui//lib/cli/ui/spinner/async.rb#41
  def stop; end

  class << self
    # Convenience method for +initialize+
    #
    # : (String title) -> Async
    #
    # source://cli-ui//lib/cli/ui/spinner/async.rb#12
    def start(title); end
  end
end

# source://cli-ui//lib/cli/ui/spinner.rb#21
CLI::UI::Spinner::GLYPHS = T.let(T.unsafe(nil), Array)

# seconds
#
# source://cli-ui//lib/cli/ui/spinner.rb#10
CLI::UI::Spinner::PERIOD = T.let(T.unsafe(nil), Float)

# source://cli-ui//lib/cli/ui/spinner.rb#13
CLI::UI::Spinner::RUNES = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#9
class CLI::UI::Spinner::SpinGroup
  # Initializes a new spin group
  # This lets you add +Task+ objects to the group to multi-thread work
  #
  # ==== Options
  #
  # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true
  # * +:interrupt_debrief+ - Automatically debrief on interrupt. Default to false
  # * +:max_concurrent+ - Maximum number of concurrent tasks. Default is 0 (effectively unlimited)
  # * +:work_queue+ - Custom WorkQueue instance. If not provided, a new one will be created
  # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
  #   or under Sorbet, IO or StringIO. Defaults to $stdout
  #
  # ==== Example Usage
  #
  #  CLI::UI::SpinGroup.new do |spin_group|
  #    spin_group.add('Title')   { |spinner| sleep 3.0 }
  #    spin_group.add('Title 2') { |spinner| sleep 3.0; spinner.update_title('New Title'); sleep 3.0 }
  #  end
  #
  # Output:
  #
  # https://user-images.githubusercontent.com/3074765/33798558-c452fa26-dce8-11e7-9e90-b4b34df21a46.gif
  #
  # : (?auto_debrief: bool, ?interrupt_debrief: bool, ?max_concurrent: Integer, ?work_queue: WorkQueue?, ?to: io_like) -> void
  #
  # @return [SpinGroup] a new instance of SpinGroup
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#63
  def initialize(auto_debrief: T.unsafe(nil), interrupt_debrief: T.unsafe(nil), max_concurrent: T.unsafe(nil), work_queue: T.unsafe(nil), to: T.unsafe(nil)); end

  # Add a new task
  #
  # ==== Attributes
  #
  # * +title+ - Title of the task
  # * +block+ - Block for the task, will be provided with an instance of the spinner
  #
  # ==== Example Usage:
  #   spin_group = CLI::UI::SpinGroup.new
  #   spin_group.add('Title') { |spinner| sleep 1.0 }
  #   spin_group.wait
  #
  # : (String title, ?final_glyph: ^(bool success) -> (Glyph | String), ?merged_output: bool, ?duplicate_output_to: IO) { (Task task) -> void } -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#304
  def add(title, final_glyph: T.unsafe(nil), merged_output: T.unsafe(nil), duplicate_output_to: T.unsafe(nil), &block); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#464
  def all_succeeded?; end

  # Provide an alternative debriefing for failed tasks
  # : { (String title, Exception? exception, String out, String err) -> void } -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#453
  def failure_debrief(&block); end

  # : (String message) -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#445
  def puts_above(message); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#324
  def stop; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#343
  def stopped?; end

  # Provide a debriefing for successful tasks
  # : { (String title, String out, String err) -> void } -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#459
  def success_debrief(&block); end

  # Tells the group you're done adding tasks and to wait for all of them to finish
  #
  # ==== Options
  #
  # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
  #   or under Sorbet, IO or StringIO. Defaults to $stdout
  #
  # ==== Example Usage:
  #   spin_group = CLI::UI::SpinGroup.new
  #   spin_group.add('Title') { |spinner| sleep 1.0 }
  #   spin_group.wait
  #
  # : (?to: io_like) -> bool
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#364
  def wait(to: T.unsafe(nil)); end

  private

  # Debriefs failed tasks is +auto_debrief+ is true
  #
  # ==== Options
  #
  # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
  #   or under Sorbet, IO or StringIO. Defaults to $stdout
  #
  # : (?to: io_like) -> bool
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#564
  def debrief(to: T.unsafe(nil)); end

  # Render messages that should appear above the spinner
  # : (io_like to, Integer consumed_lines) -> bool
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#506
  def render_puts_above(to, consumed_lines); end

  # Render all tasks
  # : (to: io_like, tasks_seen: Array[bool], tasks_seen_done: Array[bool], consumed_lines: Integer, idx: Integer, force_full_render: bool, width: Integer) -> [Integer, Integer]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#526
  def render_tasks(to:, tasks_seen:, tasks_seen_done:, consumed_lines:, idx:, force_full_render:, width:); end

  # Update progress reporter mode based on task progress states
  # : (CLI::UI::ProgressReporter::Reporter reporter, Symbol current_mode, bool first_render) -> Symbol
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#474
  def update_progress_mode(reporter, current_mode, first_render); end

  class << self
    # : Mutex
    #
    # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#14
    def pause_mutex; end

    # : [T] { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#22
    def pause_spinners(&block); end

    # : -> bool
    #
    # @return [Boolean]
    #
    # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#17
    def paused?; end
  end
end

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#10
CLI::UI::Spinner::SpinGroup::DEFAULT_FINAL_GLYPH = T.let(T.unsafe(nil), Proc)

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#79
class CLI::UI::Spinner::SpinGroup::Task
  # Initializes a new Task
  # This is managed entirely internally by +SpinGroup+
  #
  # ==== Attributes
  #
  # * +title+ - Title of the task
  # * +block+ - Block for the task, will be provided with an instance of the spinner
  #
  # : (String title, final_glyph: ^(bool success) -> (Glyph | String), merged_output: bool, duplicate_output_to: IO, work_queue: WorkQueue) { (Task task) -> untyped } -> void
  #
  # @return [Task] a new instance of Task
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#104
  def initialize(title, final_glyph:, merged_output:, duplicate_output_to:, work_queue:, &block); end

  # Checks if a task is finished
  #
  # : -> bool
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#137
  def check; end

  # Switch back to indeterminate mode
  # : -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#213
  def clear_progress; end

  # Get current progress percentage
  # : -> Integer?
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#228
  def current_progress; end

  # : bool
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#87
  def done; end

  # : Exception?
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#90
  def exception; end

  # : { (Task task) -> void } -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#130
  def on_done(&block); end

  # : Integer?
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#93
  def progress_percentage; end

  # Re-renders the task if required:
  #
  # We try to be as lazy as possible in re-rendering the full line. The
  # spinner rune will change on each render for the most part, but the
  # body text will rarely have changed. If the body text *has* changed,
  # we set @force_full_render.
  #
  # Further, if the title string includes any CLI::UI::Widgets, we
  # assume that it may change from render to render, since those
  # evaluate more dynamically than the rest of our format codes, which
  # are just text formatters. This is controlled by @always_full_render.
  #
  # ==== Attributes
  #
  # * +index+ - index of the task
  # * +force+ - force rerender of the task
  # * +width+ - current terminal width to format for
  #
  # : (Integer index, ?bool force, ?width: Integer) -> String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#175
  def render(index, force = T.unsafe(nil), width: T.unsafe(nil)); end

  # Set progress percentage (0-100) and switch to progress mode
  # : (Integer percentage) -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#204
  def set_progress(percentage); end

  # : String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#81
  def stderr; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#81
  def stdout; end

  # : bool
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#84
  def success; end

  # : String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#81
  def title; end

  # Update the spinner title
  #
  # ==== Attributes
  #
  # * +title+ - title to change the spinner to
  #
  # : (String new_title) -> void
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#194
  def update_title(new_title); end

  # Check if this task wants progress mode
  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#222
  def wants_progress_mode?; end

  private

  # : (Integer index, Integer terminal_width) -> String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#235
  def full_render(index, terminal_width); end

  # : (Integer index) -> String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#261
  def glyph(index); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#281
  def inset; end

  # : -> Integer
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#286
  def inset_width; end

  # : (Integer index) -> String
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#251
  def partial_render(index); end
end

# source://cli-ui//lib/cli/ui/spinner.rb#11
CLI::UI::Spinner::TASK_FAILED = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/stdout_router.rb#9
module CLI::UI::StdoutRouter
  class << self
    # : -> void
    #
    # @raise [NotEnabled]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#334
    def assert_enabled!; end

    # : -> Hash[Symbol, (String | io_like)]?
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#329
    def current_id; end

    # : -> bool
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#367
    def disable; end

    # : io_like?
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#311
    def duplicate_output_to; end

    # : io_like?
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#311
    def duplicate_output_to=(_arg0); end

    # : -> bool
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#353
    def enable; end

    # : (?io_like stream) -> bool
    #
    # @return [Boolean]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#362
    def enabled?(stream = T.unsafe(nil)); end

    # TODO: remove this
    # : -> void
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#348
    def ensure_activated; end

    # : [T] { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#339
    def with_enabled(&block); end

    # : [T] (on_streams: Array[io_like]) { (String id) -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#314
    def with_id(on_streams:, &block); end

    private

    # : (io_like stream, Symbol streamname) -> void
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#385
    def activate(stream, streamname); end

    # : (io_like stream) -> void
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#378
    def deactivate(stream); end
  end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#93
class CLI::UI::StdoutRouter::Capture
  # : (?with_frame_inset: bool, ?merged_output: bool, ?duplicate_output_to: IO) { -> void } -> void
  #
  # @return [Capture] a new instance of Capture
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#184
  def initialize(with_frame_inset: T.unsafe(nil), merged_output: T.unsafe(nil), duplicate_output_to: T.unsafe(nil), &block); end

  # : bool
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#200
  def print_captured_output; end

  # : bool
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#200
  def print_captured_output=(_arg0); end

  # : -> untyped
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#203
  def run; end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#246
  def stderr; end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#241
  def stdout; end

  class << self
    # : -> Capture?
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#101
    def current_capture; end

    # : -> Capture
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#106
    def current_capture!; end

    # : [T] { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#111
    def in_alternate_screen(&block); end

    # : [T] { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#138
    def stdin_synchronize(&block); end

    # : [T] { -> T } -> T
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#152
    def with_stdin_masked(&block); end

    private

    # : -> bool
    #
    # @return [Boolean]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#178
    def outermost_uncaptured?; end
  end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#250
class CLI::UI::StdoutRouter::Capture::BlockingInput
  # : (IO stream) -> void
  #
  # @return [BlockingInput] a new instance of BlockingInput
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#252
  def initialize(stream); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def <<(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def advise(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def autoclose=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def autoclose?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def binmode(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def binmode?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def close(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def close_on_exec=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def close_on_exec?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def close_read(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def close_write(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def closed?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def each(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def each_byte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def each_char(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def each_codepoint(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def each_line(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def eof(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def eof?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def external_encoding(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def fcntl(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def fdatasync(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def fileno(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def flush(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def fsync(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def getbyte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def getc(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def getch(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def gets(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def inspect(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def internal_encoding(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def ioctl(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def isatty(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def lineno(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def lineno=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def nread(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def path(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def pathconf(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def pid(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def pos(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def pos=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def pread(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def print(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def printf(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def putc(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def puts(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def pwrite(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def read(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def read_nonblock(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def readbyte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def readchar(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def readline(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def readlines(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#290
  def readpartial(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def ready?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def reopen(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def rewind(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def seek(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def set_encoding(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def set_encoding_by_bom(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def stat(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def sync(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def sync=(*args, **kwargs, &block); end

  # : [T] { -> T } -> T
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#258
  def synchronize(&block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def sysread(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def sysseek(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def syswrite(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def tell(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def timeout(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def timeout=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def to_i(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def to_io(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def to_path(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def tty?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def ungetbyte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def ungetc(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def wait(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def wait_priority(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def wait_readable(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def wait_writable(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def write(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#298
  def write_nonblock(*args, **kwargs, &block); end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#287
CLI::UI::StdoutRouter::Capture::BlockingInput::NON_READING_METHODS = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/stdout_router.rb#268
CLI::UI::StdoutRouter::Capture::BlockingInput::READING_METHODS = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/stdout_router.rb#10
class CLI::UI::StdoutRouter::Writer
  # : (io_like stream, Symbol name) -> void
  #
  # @return [Writer] a new instance of Writer
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#12
  def initialize(stream, name); end

  # : (*Object args) -> Integer
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#18
  def write(*args); end

  private

  # : (String str, String prefix) -> String
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#76
  def apply_line_prefix(str, prefix); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#71
  def auto_frame_inset?; end

  # : (io_like stream, Array[String] args) -> Array[String]
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#52
  def prepend_id(stream, args); end

  # : (io_like stream) -> bool
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#63
  def prepend_id_for_stream(stream); end
end

# source://cli-ui//lib/cli/ui/table.rb#5
module CLI::UI::Table
  class << self
    # Captures a table's output as an array of strings without printing to the terminal
    # Can be used to further manipulate or format the table output
    #
    # ==== Attributes
    #
    # * +table+ - (required) 2D array of strings representing the table data
    #
    # ==== Options
    #
    # * +:col_spacing+ - Number of spaces between columns. Defaults to 1
    #
    # ==== Returns
    #
    # * +Array[String]+ - Array of strings, each representing a row of the formatted table
    #
    # ==== Example
    #
    #   CLI::UI::Table.capture_table([
    #     ["{{bold:header_1}}", "{{bold:header_2}}"],
    #     ["really_long_cell",  "short"],
    #     ["row2",              "row2"]
    #   ])
    #
    # : (Array[Array[String]] table, ?col_spacing: Integer) -> Array[String]
    #
    # source://cli-ui//lib/cli/ui/table.rb#75
    def capture_table(table, col_spacing: T.unsafe(nil)); end

    # Prints a formatted table to the specified output
    # Automatically pads columns to align based on the longest cell in each column,
    # ignoring the width of ANSI color codes.
    #
    # ==== Attributes
    #
    # * +table+ - (required) 2D array of strings representing the table data
    #
    # ==== Options
    #
    # * +:col_spacing+ - Number of spaces between columns. Defaults to 1
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout
    #
    # ==== Example
    #
    #   CLI::UI::Table.puts_table([
    #     ["{{bold:header_1}}", "{{bold:header_2}}"],
    #     ["really_long_cell",  "short"],
    #     ["row2",              "row2"]
    #   ])
    #
    # Default Output:
    #   header_1         header_2
    #   really_long_cell short
    #   row2             row2
    #
    # : (Array[Array[String]] table, ?col_spacing: Integer, ?to: io_like) -> void
    #
    # source://cli-ui//lib/cli/ui/table.rb#35
    def puts_table(table, col_spacing: T.unsafe(nil), to: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/terminal.rb#8
module CLI::UI::Terminal
  class << self
    # Returns the width of the terminal, if possible
    # Otherwise, will return DEFAULT_HEIGHT
    #
    # : -> Integer
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#25
    def height; end

    # : -> void
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#46
    def setup_winsize_trap; end

    # Returns the width of the terminal, if possible
    # Otherwise will return DEFAULT_WIDTH
    #
    # : -> Integer
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#17
    def width; end

    # : -> [Integer, Integer]
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#30
    def winsize; end
  end
end

# source://cli-ui//lib/cli/ui/terminal.rb#10
CLI::UI::Terminal::DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/terminal.rb#9
CLI::UI::Terminal::DEFAULT_WIDTH = T.let(T.unsafe(nil), Integer)

# Truncater truncates a string to a provided printable width.
#
# source://cli-ui//lib/cli/ui/truncater.rb#7
module CLI::UI::Truncater
  class << self
    # : (String text, Integer printing_width) -> String
    #
    # source://cli-ui//lib/cli/ui/truncater.rb#30
    def call(text, printing_width); end

    private

    # : (Integer printable_codepoint) -> Integer
    #
    # source://cli-ui//lib/cli/ui/truncater.rb#93
    def width(printable_codepoint); end
  end
end

# EMOJI_RANGE in particular is super inaccurate. This is best-effort.
# If you need this to be more accurate, we'll almost certainly accept a
# PR improving it.
#
# source://cli-ui//lib/cli/ui/truncater.rb#21
CLI::UI::Truncater::EMOJI_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#13
CLI::UI::Truncater::ESC = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#23
CLI::UI::Truncater::LC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#14
CLI::UI::Truncater::LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#22
CLI::UI::Truncater::NUMERIC_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#9
CLI::UI::Truncater::PARSE_ANSI = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#10
CLI::UI::Truncater::PARSE_ESC = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#8
CLI::UI::Truncater::PARSE_ROOT = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#11
CLI::UI::Truncater::PARSE_ZWJ = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#16
CLI::UI::Truncater::SEMICOLON = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#26
CLI::UI::Truncater::TRUNCATED = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/truncater.rb#24
CLI::UI::Truncater::UC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)

# emojipedia.org/emoji-zwj-sequences
#
# source://cli-ui//lib/cli/ui/truncater.rb#15
CLI::UI::Truncater::ZWJ = T.let(T.unsafe(nil), Integer)

# Widgets are formatter objects with more custom implementations than the
# other features, which all center around formatting text with colours,
# etc.
#
# If you want to extend CLI::UI with your own widgets, you may want to do
# something like this:
#
#   require('cli/ui')
#   class MyWidget < CLI::UI::Widgets::Base
#     # ...
#   end
#   CLI::UI::Widgets.register('my-widget') { MyWidget }
#   puts(CLI::UI.fmt("{{@widget/my-widget:args}}"))
#
# source://cli-ui//lib/cli/ui/widgets.rb#21
module CLI::UI::Widgets
  class << self
    # All available widgets by name
    #
    # : -> Array[String]
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#51
    def available; end

    # Looks up a widget by handle
    #
    # ==== Raises
    # Raises InvalidWidgetHandle if the widget is not available.
    #
    # ==== Returns
    # A callable widget, to be invoked like `.call(argstring)`
    #
    # : (String handle) -> singleton(Widgets::Base)
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#42
    def lookup(handle); end

    # : (String name) { -> singleton(Widgets::Base) } -> void
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#29
    def register(name, &cb); end
  end
end

# @abstract
#
# source://cli-ui//lib/cli/ui/widgets/base.rb#10
class CLI::UI::Widgets::Base
  # : (String argstring) -> void
  #
  # @return [Base] a new instance of Base
  #
  # source://cli-ui//lib/cli/ui/widgets/base.rb#19
  def initialize(argstring); end

  # : -> String
  #
  # @abstract
  # @raise [NotImplementedError]
  #
  # source://cli-ui//lib/cli/ui/widgets/base.rb#40
  def render; end

  class << self
    # : -> Regexp
    #
    # @abstract
    # @raise [NotImplementedError]
    #
    # source://cli-ui//lib/cli/ui/widgets/base.rb#33
    def argparse_pattern; end

    # : (String argstring) -> String
    #
    # source://cli-ui//lib/cli/ui/widgets/base.rb#13
    def call(argstring); end
  end
end

# source://cli-ui//lib/cli/ui/widgets.rb#73
class CLI::UI::Widgets::InvalidWidgetArguments < ::ArgumentError
  # : (String argstring, Regexp pattern) -> void
  #
  # @return [InvalidWidgetArguments] a new instance of InvalidWidgetArguments
  #
  # source://cli-ui//lib/cli/ui/widgets.rb#75
  def initialize(argstring, pattern); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets.rb#82
  def message; end
end

# source://cli-ui//lib/cli/ui/widgets.rb#58
class CLI::UI::Widgets::InvalidWidgetHandle < ::ArgumentError
  # : (String handle) -> void
  #
  # @return [InvalidWidgetHandle] a new instance of InvalidWidgetHandle
  #
  # source://cli-ui//lib/cli/ui/widgets.rb#60
  def initialize(handle); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets.rb#66
  def message; end
end

# source://cli-ui//lib/cli/ui/widgets.rb#22
CLI::UI::Widgets::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/widgets/status.rb#9
class CLI::UI::Widgets::Status < ::CLI::UI::Widgets::Base
  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#34
  def render; end

  private

  # : (String num_str, String rune, Color color) -> String
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#51
  def colorize_if_nonzero(num_str, rune, color); end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#62
  def failed_part; end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#73
  def pending_part; end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#57
  def succeeded_part; end

  # : -> String
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#67
  def working_part; end

  # : (String num_str) -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/widgets/status.rb#46
  def zero?(num_str); end

  class << self
    # : -> Regexp
    #
    # source://cli-ui//lib/cli/ui/widgets/status.rb#27
    def argparse_pattern; end
  end
end

# source://cli-ui//lib/cli/ui/widgets/status.rb#10
CLI::UI::Widgets::Status::ARGPARSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/widgets/status.rb#18
CLI::UI::Widgets::Status::ARROW = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#17
CLI::UI::Widgets::Status::CLOSE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#19
CLI::UI::Widgets::Status::COMMA = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#22
CLI::UI::Widgets::Status::EMPTY_SET = T.let(T.unsafe(nil), String)

# e.g. "1:23:3:404"
#
# source://cli-ui//lib/cli/ui/widgets/status.rb#16
CLI::UI::Widgets::Status::OPEN = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#21
CLI::UI::Widgets::Status::SPINNER_STOPPED = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/work_queue.rb#6
class CLI::UI::WorkQueue
  # : (Integer max_concurrent) -> void
  #
  # @return [WorkQueue] a new instance of WorkQueue
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#68
  def initialize(max_concurrent); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#87
  def close; end

  # : { -> untyped } -> Future
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#77
  def enqueue(&block); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#98
  def interrupt; end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#92
  def wait; end

  private

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#116
  def start_worker; end
end

# source://cli-ui//lib/cli/ui/work_queue.rb#7
class CLI::UI::WorkQueue::Future
  # : -> void
  #
  # @return [Future] a new instance of Future
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#9
  def initialize; end

  # : (untyped result) -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#19
  def complete(result); end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#49
  def completed?; end

  # : (Exception error) -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#28
  def fail(error); end

  # : -> void
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#59
  def start; end

  # : -> bool
  #
  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#54
  def started?; end

  # : -> untyped
  #
  # source://cli-ui//lib/cli/ui/work_queue.rb#39
  def value; end
end

# source://cli-ui//lib/cli/ui/wrap.rb#10
class CLI::UI::Wrap
  # : (String input) -> void
  #
  # @return [Wrap] a new instance of Wrap
  #
  # source://cli-ui//lib/cli/ui/wrap.rb#12
  def initialize(input); end

  # : (?Integer total_width) -> String
  #
  # source://cli-ui//lib/cli/ui/wrap.rb#17
  def wrap(total_width = T.unsafe(nil)); end
end
